#!/usr/bin/env python3
# This is a script intended to track your project activities.
# It is really simple and I got the idea when using todolist on the command
# line. tymetracker (tt) is written entirely in Python 3 and stores the
# records in a json data structure in the user's home directory.
datafile = "~/.tt.json"
dateformat = "%Y-%m-%dT%H:%M:%S"

# Exit codes
# There are a couple of exit codes that can occur when running tt. 
# Code  Meaning
# -----+---------------------------------------------------------------------
#    0  OK
#    1  Python Version < 3.x
#    2  Data file should be initialized but does already exist
#    3  Data file not found
#    4  Other exception while trying to read data file
#    5  Could not read data from data file
#    7  Exception while saving/writing data to data file
#   10  Project's name or ID not specified when trying to add a new project
#   11  Project's name or ID not specified when trying to delete/rename p.
#   12  Project with given name or ID could not be found
#   13  Not allowed to alter special project
#   20  Project's name or ID not specified when trying to start tracker
#   21  Tracker already started
#   22  No tracker found
#   23  Not allowed to start or stop tracker for special project
#   24  Tracker already paused
#   30  Alias or command not specified when adding alias
#   31  Invalid command when trying to add alias
#   32  Alias not found
#   42  Disabled in local configuration


#############################################################################
### Here be dragons!
#############################################################################

# Import stuff we need
import copy
import datetime
import json
import os
import sys


# This variable defines the format version of the datafile
DATAFILE_VERSION = 4


# Set variables we need
f = os.path.abspath(os.path.expanduser(datafile))
my_name = os.path.basename(sys.argv[0])


# Cache for data
DATA = None


# Sanity check: only proceed if we are in a python3 environment
try:
    assert sys.version_info >= (3,0)
except:
    print("Python 3 is required to run {}".format(my_name))
    sys.exit(1)




#############################################################################
### Helper functions
#############################################################################

class bcolors:
    """
    Define some colors that can be used in the terminal.
    Source: https://gist.github.com/vratiu/9780109
    """
    # Reset
    END = "\033[0m"             # Text Reset
    
    # Regular Colors
    BLACK = "\033[0;30m"        # Black
    RED = "\033[0;31m"          # Red
    GREEN = "\033[0;32m"        # Green
    YELLOW = "\033[0;33m"       # Yellow
    BLUE = "\033[0;34m"         # Blue
    PURPLE = "\033[0;35m"       # Purple
    CYAN = "\033[0;36m"         # Cyan
    WHITE = "\033[0;37m"        # White

    # Bold
    BBLACK="\033[1;30m"         # Black
    BRED = "\033[1;31m"         # Red
    BGREEN = "\033[1;32m"       # Green
    BYELLOW = "\033[1;33m"      # Yellow
    BBLUE = "\033[1;34m"        # Blue
    BPURPLE = "\033[1;35m"      # Purple
    BCYAN = "\033[1;36m"        # Cyan
    BWHITE = "\033[1;37m"       # White
    
    # Underline
    UBLACK = "\033[4;30m"       # Black
    URED = "\033[4;31m"         # Red
    UGREEN = "\033[4;32m"       # Green
    UYELLOW = "\033[4;33m"      # Yellow
    UBLUE = "\033[4;34m"        # Blue
    UPURPLE = "\033[4;35m"      # Purple
    UCYAN = "\033[4;36m"        # Cyan
    UWHITE = "\033[4;37m"       # White



def _get_project_id(data, project_id_or_name):
    """Look up and return a project's ID if it exists.

    If the project ID is given, this ID will be returned if the project
    exists in the data. If a project's name is given, this function
    looks up the name in data and return the ID of the project.
    If the project could not be found, this function returns None.

    :param data:                Data object representing the current state
    :type data:                 dict
    :param project_id_or_name:  Argument given by caller representing either a project ID or name
    :type project_id_or_name:   str
    :return:                    ID of the project in the data object
    :rtype:                     str
    """
    # print(type(project_id_or_name))
    pin = None
    if isinstance(project_id_or_name, str):
        pin = project_id_or_name
    elif isinstance(project_id_or_name, list):
        pin = " ".join(project_id_or_name)
    else:
        print("Could not look up project ID for {} ({})".format(project_id_or_name, type(project_id_or_name)))
        return None


    # If we have a positive number project_id_or_name could be the
    # ID itself. Let's check
    if pin.isdigit() or pin in ['p']:
        if pin in data["projects"].keys():
            return pin
            # return project_id_or_name

    # project_id_or_name is not the project ID. Let's search all projects'
    # names
    for project_id, project in data["projects"].items():
        if pin == project["name"]:
            return project_id

    # Ok, did not find anything yet. Maybe the case of the letters is
    # different... since we found nothing yet, let's try that.
    # Note, that case-removing conversions in unicode aren't trivial. There
    # is text for which text.lower() != text.upper().lower(), such as "ß":
    #  "ß".lower()
    #  #>>> 'ß'
    #  "ß".upper().lower()
    #  #>>> 'ss'
    for project_id, project in data["projects"].items():
        if pin.lower() == project["name"].lower():
            return project_id

    # We could not find the string neither in the IDs nor in the names.
    # Giving up.
    print("Project {cb}{pid}{ce} not found".format(cb=bcolors.YELLOW, pid=project_id_or_name, ce=bcolors.END))
    sys.exit(12)

    return None


def _get_project_name(data, project_id):
    """Return the name of a project.

    Get a project's name. Consider using _project_name() function below if
    you need to display the project's name in-line.

    :param data:        Data object representing the current state
    :type data:         dict
    :param project_id:  ID of project
    :type project_id:   str
    :return:            Name of the project
    :rtype:             str
    """
    try:
        return data["projects"][project_id]["name"]
    except:
        return None


def _project_name(data, project_id):
    """Return a colored string representing a project.

    Returns a string that can be used every time when a project's name needs
    do be displayed. Using this function makes sure that the name is always
    printed in the same way making it easier to use tt.

    :param data:        Data object representing the current state
    :type data:         dict
    :param project_id:  ID of project
    :type project_id:   str
    :return:            Colored string to print on the command line
    :rtype:             str or None
    """
    pname = _get_project_name(data, project_id)
    if pname is not None:
        if type(project_id) is int:
            # r = "\"{cpb}{pname}{ce}\" ({cib}{i}{ce})".format(
            r = "{cib}{i}{ce}: \"{pname}\"".format(
                                                     cpb=bcolors.END,
                                                     pname=pname,
                                                     ce=bcolors.END,
                                                     cib=bcolors.YELLOW,
                                                     i=project_id)
        else:
            r = "{cib}{i}{ce}: \"{pname}\"".format(
                                                     cpb=bcolors.END,
                                                     pname=pname,
                                                     ce=bcolors.END,
                                                     cib=bcolors.BLUE,
                                                     i=project_id)
    else:
        r = None

    return r


def _timestamp():
    """Return a timestamp.

    This timestamp is crucial since it is used in the JSON file to store
    the beginning and end of the the time periods.
    We use the ISO format to ensure that humans can read (and modify) the
    values manually if needed.

    :return:    Return a timestamp used to calculate tracking times
    :rtype:     str
    """
    return datetime.datetime.now().strftime(dateformat)


def _time_diff(started, stopped):
    """
    Calculate the difference between to datetimes.
    Returns a 3-tuple containing
        seconds as float (e.g., 23132.0 seconds)
        hour_frac as float (e.g., 0.3455353 hours)
        hhmm as string (e.g., 01:23)
    """
    a = datetime.datetime.strptime(started, dateformat)
    b = datetime.datetime.strptime(stopped, dateformat)
    c = b - a
    seconds = c.total_seconds()
    hour_frac = seconds / 3600
    hhmm = "{h:02}:{m:02}".format(h=c.seconds//3600, m=(c.seconds//60)%60)

    # return tuple
    return (seconds, hour_frac, hhmm)


def _to_day_and_time(isodateformat):
    """
    Return the day and the time from an ISO-formatted date.
    Given a timestamp, the day and the time will be returned as a 2-tuple with
    the day in format YYYY-mm-dd as first element and the time in format HH:MM
    as the second element of the tuple.
    """
    day = datetime.datetime.strptime(isodateformat, dateformat).strftime('%Y-%m-%d')
    time = datetime.datetime.strptime(isodateformat, dateformat).strftime('%H:%M')
    return (day, time)



#############################################################################
### Configuration functions
#############################################################################


def enable_log():
    """Enable log functionality.

    This function reconfigures and saves the particular setting in the
    data files's config section.
    """
    data = load()
    if not data["config"]["log_actions"]:
        msg = "Enabled log"
        data["config"]["log_actions"] = True
        print(msg)
        save(data, msg)
    else:
        print("Log already enabled")


def disable_log():
    """Disable log functionality.

    This function reconfigures and saves the particular setting in the
    data files's config section.
    """
    data = load()
    if data["config"]["log_actions"]:
        msg = "Disabled log"
        data["config"]["log_actions"] = False
        print(msg)
        save(data, msg)
    else:
        print("Log already disabled")


def enable_pause():
    """Enable tracking pause times.

    This function reconfigures and saves the particular setting in the
    data files's config section.
    """
    data = load()
    if not data["config"]["log_pause_times"]:
        msg = "Enabled tracking of pause times"
        data["config"]["log_pause_times"] = True
        print(msg)
        save(data, msg)
    else:
        print("Tracking of pause times already enabled")


def disable_pause():
    """Disable tracking pause times.

    This function reconfigures and saves the particular setting in the
    data files's config section.
    """
    data = load()
    if data["config"]["log_pause_times"]:
        msg = "Disabled tracking of pause times"
        data["config"]["log_pause_times"] = False
        print(msg)
        save(data, msg)
    else:
        print("Tracking of pause times already disabled")



#############################################################################
### Data file functions
#############################################################################

def load():
    """Load data file contents.

    Load the JSON datafile and return a dict with all the values.

    :return:    Data object representing the current state
    :rtype:     dict
    """
    global DATA
    if DATA:
        return DATA

    try:
        fp = open(f, "r")
        data = json.load(fp)
        fp.close()
    except FileNotFoundError as e:
        print("Could not load data file. Please run", bcolors.YELLOW, "init", bcolors.END, "first.")
        sys.exit(3)
    except Exception as e:
        print(e)
        sys.exit(4)

    if data is None:
        print("Read corrupt data from", f)
        sys.exit(5)

    # Apply upgrade to the data read from the disk (if needed)
    data = _file_version_upgrade(data)
    DATA = data

    return data


def save(data, msg = None):
    """Write the data dict object to disk in JSON format.

    If a msg is set, this text will be appended to the log in the datafile
    if logging in the config section is set to True (which is the default).

    :param data:    Data object representing the current state
    :type data:     dict
    :param msg:     ID of project
    :type msg:      str
    """
    if data is not None:
        if msg is not None and data.get("config", {}).get("log_actions", False):
            data.get("log", []).append("{ts}  {msg}".format(ts = _timestamp().replace('T', ' '), msg = msg))

        global DATA
        DATA = data

        try:
            fp = open(f, "w")
            json.dump(data, fp, indent=2)
            fp.flush()
            fp.close()
        except Exception as e:
            print(e)
            sys.exit(7)
    else:
        print("No data to write")


def _file_version_upgrade(data = None):
    """This function migrates a data file from on old version to a new version.

    If the data object is given as an argument, this function will operate on
    the provided data object otherwise the data will be loaded from disk.
    The version of the data file and the version needed by tt will be
    compared. If needed, modifications are applied to the data object.
    After applying all modifications the data object is stored to disk and
    is returned by this function.

    :param data:    (Optional) Data object representing the current state
    :type data:     dict
    :return:        Return updated data object
    :rtype:         dict
    """
    # Load the data from the datafile on disk (if needed)
    if data is None:
        data = load()

    # Determine the version of the data file as well as the version
    # we need to migrate to 
    from_version = int(data["meta"]["file_version"])
    to_version = int(DATAFILE_VERSION)

    # Check if changes need to be made, otherwise return data object
    if from_version >= to_version:
        return data

    current_version = from_version
    while current_version < to_version:
        if current_version == 1:
            data["meta"]["file_version"] = 2
            data["meta"]["last_project"] = None
            data["config"] = {"log_pause_times": True, "log_actions": True,}
            data["projects"]["p"] = {"name": "Pause", "history": []}
            data["log"] = []

        if current_version == 2:
            data["meta"]["file_version"] = 3
            data["tracking"]["comment"] = None  # Comments are stored here (as str)

            for project_id, project_data in data["projects"].items():

                # We need to build a new history for every project
                # The old history contains 2-tuples with the start time
                # and the end time of the tracker, the new history
                # is a 3-tuple conainting an additional string
                # representing a comment regarding this stint.
                # This comment is None by default.
                old_history = project_data["history"]
                new_history = []

                for (start_tracking, end_tracking) in old_history:
                    print("Updating tuple: {} - {}".format(start_tracking, end_tracking))
                    new_tuple = (start_tracking, end_tracking, None)
                    new_history.append(new_tuple)

                data["projects"][project_id]["history"] = new_history

        if current_version == 3:
            data["meta"]["file_version"] = 4
            data["aliases"] = {
                    "st": "status",
                    "a": "add",
                    "d": "delete",
                    "l": "list",
                    "ch": "change",
                    "c": "comment",
                    "p": "pause",
                    "r": "resume",
                    "s": "show",
                    "sw": "switch",
                    }

        # increment current_version to carry out next update if needed
        current_version += 1

    msg = "Converted data file format from version {f} to version {t}".format(f = from_version, t = to_version)
    save(data, msg)
    print(msg)

    # Return upgraded data object
    return data



#############################################################################
### Generic functions
#############################################################################

def init():
    """Initialize a new datafile if it does not exist.

    If a data file already exists, the program will return with an error code.
    If an existing data file should be overwritten, the user needs to
    manually delete the existing file.

    The new data file will be written to disk and the program will exit.
    """
    if os.path.isfile(f):
        print("Data file {} already exists".format(f))
        sys.exit(2)
    else:
        print("Initializing new data file {}".format(f))

        # Initialize new data dict
        data = {
                "meta": {
                    "last_id": 0,
                    "file_version": 4,
                    "last_project": None,
                    },
                "config": {
                    "log_pause_times": True,
                    "log_actions": True,
                    },
                "tracking": {
                    "active": False,
                    "project": None,
                    "started": None,
                    "comment": None,
                    },
                "aliases": {
                    "st": "status",
                    "a": "add",
                    "d": "delete",
                    "l": "list",
                    "ch": "change",
                    "c": "comment",
                    "p": "pause",
                    "r": "resume",
                    "s": "show",
                    "sw": "switch",
                },
                "projects": {
                    # id:    {
                        # "name": Projektname,
                        # "history": [] # elements are tuples (start, stop)
                    # }
                    # },

                    # This is the special project "Pause".
                    # This project is used for pause/resume timekeeping.
                    "p": {
                        "name": "Pause",
                        "history": [],
                        }
                    },
                "log": [],
                },

        # ... and write it to data file
        save(data, "Initialized new data file")


def status():
    """Print current state.

    If a tracker is active this function displays a brief summary of the
    recent work period.
    """
    data = load()

    # number_of_projects = len(data["projects"])

    # # If pause times should not be logged we need to hide the project
    # # from the user
    # if not data.get("config", {}).get("log_pause_times", False):
    #     number_of_projects -= 1

    # print("{} projects".format(number_of_projects))

    if not data["tracking"]["active"]:
        print("No active time tracking")
    else:
        since = data["tracking"]["started"]
        project_id = data["tracking"]["project"]
        comment = data["tracking"]["comment"]
        _, hf, hhmm = _time_diff(since, _timestamp())
        msg = "Tracking time in project {name} for {hhmm} ({hf:0.2f} hours)".format(name=_project_name(data, project_id), hf=hf, hhmm=hhmm)

        if comment:
            msg += ": \"{c}\"".format(c = comment)

        print(msg)

def print_log(limit = 20):
    """Print log.

    If the log is enabled in the local configuration existing log entries
    are printed to the console.
    The user can also privde "enable", "disable", or a number as argument
    together with the log keyword. If enable or disable is given, the
    appropriate configuration update is carried out. If a number is given
    this number is treated as the number of log entries to print.
    """
    if len(sys.argv) == 3:
        if sys.argv[2].lower() == "enable":
            enable_log()
            sys.exit(0)
        elif sys.argv[2].lower() == "disable":
            disable_log()
            sys.exit(0)
        elif sys.argv[2].isdigit():
            # Display last n entries
            limit = int(sys.argv[2])

    data = load()
    if not data["config"]["log_actions"]:
        print("Disabled in local config")
        sys.exit(42)

    # Get the last limit entries of the list of log entries
    history = data["log"][-limit:]

    # Print the log
    for line in history:
        print("{indent}{msg}".format(indent = " " * 2, msg = line))


def cleanup():
    """Clean up the projects.

    This function will reassign new IDs to the project.
    After the reorganization the file is saved to disk.
    """
    data = load()

    # iterate the projects and reassign new IDs
    old_projects = copy.deepcopy(data["projects"])
    project_id = 0
    data["projects"] = {}
    for old_pid, project in old_projects.items():
        if old_pid == "pause":
            data["projects"]["pause"] = project
        else:
            project_id = project_id + 1
            data["projects"][project_id] = project

    # set the correct last ID
    data["meta"]["last_id"] = project_id

    # write to disk
    save(data, "Cleaned up data file")
    print("Successfully cleaned up {}".format(datafile))


def parse_command(command_or_alias):
    """Returns the name of a command (for an alias if defined).

    The data file allows aliases to be defined to shorten commands the user
    needs to type in.
    This function returns the full command for a given alias if this
    alias exists in the data file.
    If the complete function name is given in the alias attribute and
    such a command exists, this name will also be returned.

    :return:    Command name that should be carried out
    :rtype:     str or None
    """
    data = load()
    commands = get_commands()

    if command_or_alias in commands:
        return command_or_alias
    else:
        resolved_alias = data.get("aliases", {}).get(command_or_alias, None)
        if resolved_alias and resolved_alias in commands:
            return resolved_alias

    return None



def get_command_groups():
    """Defines the commands and the groups where they belong.

    The dict that will be returned contains other dictionaries, each
    representing a group of commands. These dictionaries can contain
    a reserved key DESC that provides a human-readable short description
    of this command group.

    :return:    Group of commands used to display the help message
    :rtype:     dict of dicts
    """
    group = {
            "Generic commands": {
                "DESC": "Commands to initialize {} and perform management tasks.".format(my_name),
                "init": "Initialize new data file",
                "status": "Display tracker status information",
                "cleanup": "Cleanup and reorganize data file",
                "log": "Show activity log",
                "log enable": "Enable activity log",
                "log disable": "Disable activity log",
                "aliases": "Shows list of all defined aliases",
                "alias a command": "Create or updates alias a for a particular command",
                "unalias a": "Remove alias a",
                },
            "Projects": {
                "DESC": "Before you can start a tracker you need to create a project to which this tracker is assigned. These commands allow you to add, delete and manage existing projects.",
                "add project name": "Add new project with name \"project name\"",
                "delete 23": "Delete project with id 23",
                "list": "List projects and their ids",
                "rename 23 new name": "Rename project with ID 23 to \"new name\"",
                },
            "Tracking": {
                "DESC": "These commands allow to start and stop trackers as well as displaying tracked times in existing projects.",
                "start 23": "Start time tracking for project id 23",
                "stop": "Stop active time tracking",
                "pause": "Pause an active tracker",
                "pause disable": "Disable tracking of pause times",
                "pause enable": "Enable tracking of pause times",
                "resume": "Resume tracker from paused project or from last project used",
                "show": "Show tracked times for all projects",
                "show 23": "Show tracked times and some additional information for project 23",
                "switch 23": "Switch a tracker to a new project by stopping it and starting a new",
                "change 23": "Chance project assigned to an active tracker",
                "cancel": "Cancel active tracker and dismiss time",
                "reset": "Reset time of active tracker",
                "comment comment": "Add \"comment\" to the current active tracker",
                }
            }

    dict_of_aliases = get_aliases()
    if len(dict_of_aliases):
        dict_of_aliases["DESC"] = "Aliases defined in the data file"
        group["Aliases"] = dict_of_aliases

    return group


def get_commands():
    """Returns a set of all commands available by this version of tt.

    This set does not contain aliases defined in the data file but only
    full commands. It will be used for input parsing.

    :return:    All commands available to the user
    :rtype:     Set of strings
    """
    groups = get_command_groups()
    result = set()

    for group_name, group in groups.items():
        if group_name != "Aliases":
            for command in group.keys():
                if command != "DESC":
                    result.add(command.split(" ")[0])

    return result




def usage():
    """Print the list of commands that are supported.

    This function is called everytime  the user calls tt with no or too
    few arguments.
    """
    group = get_command_groups()

    # Display the commands/dicts
    first = True
    for group, commands in group.items():
        if first:
            first = False
        else:
            print("\n")
        print(bcolors.PURPLE, "{group}".format(group=group), bcolors.END)

        # print the DESC if needed
        if "DESC" in commands:
            print("     {desc}\n".format(desc=commands["DESC"]))

        # print all commands (and not DESC)
        for command, description in sorted(commands.items()):
            if command is not "DESC":
                print(bcolors.YELLOW, "    {cmd:20s}".format(cmd=command), bcolors.END, description)



def get_aliases():
    """Return a dict containing all aliases defined.

    Key is the alias, value is the command to call.

    :return:    All defined aliases
    :rtype:     dict
    """
    data = load()
    aliases = data.get("aliases", {})

    dict_of_aliases = {}
    if len(aliases) > 0:

        for alias, command in aliases.items():
            dict_of_aliases[alias] = command

    return dict_of_aliases




def print_aliases():
    """Print list of defined aliases.
    """
    aliases = get_aliases()
    for alias, command in sorted(aliases.items()):
        print("{:>4}    {}".format(alias, command))


def alias():
    """Add or update an alias for a particular command.

    The alias will only be added to the data file if a valid command is
    specified.
    """
    if len(sys.argv) < 4:
        print("You must specify alias and command")
        sys.exit(30)

    data = load()
    alias = sys.argv[2]
    command = sys.argv[3]

    if command in get_commands():
        data["aliases"][alias] = command
        msg = "Created alias {alias} for command {cmd}".format(alias = alias, cmd = command)
        save(data, msg)
        print(msg)
    else:
        print("Could not create alias {} for {}: Invalid command".format(alias, command))
        sys.exit(31)


def unalias():
    """Removes alias from the data file.
    """
    if len(sys.argv) < 3:
        print("You must specify alias to remove")
        sys.exit(30)

    data = load()
    alias = sys.argv[2]

    if alias in data["aliases"].keys():
        msg = "Removed alias {alias} for {cmd}".format(alias = alias, cmd = data["aliases"][alias])
        del data["aliases"][alias]
        save(data, msg)
        print(msg)
    else:
        print("Alias {} not defined".format(alias))
        sys.exit(32)


#############################################################################
### Projects
#############################################################################

def list_projects():
    """Print all existing projects.

    The special project p is only displayed if tracking pause times is enabled
    in the local configuration.
    """
    data = load()
    p = data.get("projects", {})
    show_pause_project = data.get("config", {}).get("log_pause_times", False)

    if len(p) == 0:
        print("No projects found.")
    else:
        for project_id, project_data in sorted(p.items()):
            if project_id == "p" and not show_pause_project:
                continue
            #print("    {i:>3}   {n}".format(i=project_id, n=project_data["name"]))
            if project_id.isdigit():
                print("    {cb}{i:>3}{ce}   {n}".format(cb=bcolors.YELLOW, i=project_id, ce=bcolors.END, n=project_data["name"]))
            else:
                print("    {cb}{i:>3}{ce}   {n}".format(cb=bcolors.BLUE, i=project_id, ce=bcolors.END, n=project_data["name"]))


def add_project():
    """Add a project.

    You need to specify a project name. The project name can contain spaces.
    When created, this function prints the id of the created project.
    """
    if len(sys.argv) < 3:
        print("You must specify a project name")
        sys.exit(10)

    name = " ".join(sys.argv[2:]).strip()

    data = load()
    project = {}
    project_id = int(data["meta"].get("last_id", 0)) + 1

    # If there is a bogus last_id in our file, we need to make sure that no
    # existing data will be overwritten

    # We build a list of ints here. It is noteworthy that .keys() gives us a
    # dict_keys object of strings. The map function converts all these
    # strings to int.
    # existing_projects = set(data.get("projects", {}).keys())
    # print(existing_projects)
    # sys.exit(0)
    # remove ID 'p' of pause project
    # del existing_projects['p']
    # existing_project_ids = map(int, data.get("projects", {}).keys())
    existing_project_ids = [i for i in data.get("projects", {}).keys() if type(i) is int ]
    if project_id in existing_project_ids:
        # Get the biggest existing project ID and increase it by 1
        project_id = max(existing_project_ids) + 1

    project["name"] = name
    project["history"] = []

    projects = data.get("projects", {})
    projects[project_id] = project

    data["meta"]["last_id"] = project_id
    data["projects"] = projects

    msg = "Created project {name}".format(name=_project_name(data, project_id))
    save(data, msg)
    print(msg)


def del_project():
    """Delete a project.

    You need to specify a project id.
    """
    if len(sys.argv) < 3:
        print("You must specify a project id")
        list_projects()
        sys.exit(11)

    data = load()
    project_id = _get_project_id(data, sys.argv[2:])

    if project_id not in data.get("projects", {}).keys():
        print("Project {cb}{pid}{ce} not found".format(cb=bcolors.YELLOW, pid=project_id, ce=bcolors.END))
        sys.exit(12)
    elif not project_id.isdigit():
        print("Not allowed to delete special project {name}".format(name=_project_name(data, project_id)))
    else:
        msg = "Project {name} deleted".format(name=_project_name(data, project_id))
        del data["projects"][project_id]
        print(msg)
        save(data, msg)


def rename_project():
    """Rename a project.

    You need to specify a project id and a new project name.
    """
    if len(sys.argv) < 4:
        print("You must specify a project id and a new project name")
        list_projects()
        sys.exit(11)

    project_id = sys.argv[2]
    new_name = " ".join(sys.argv[3:])

    data = load()
    if project_id not in data.get("projects", {}):
        print("Project {cb}{pid}{ce} not found".format(cb=bcolors.YELLOW, pid=project_id, ce=bcolors.END))
        sys.exit(12)
    elif not project_id.isdigit():
        print("Not allowed to rename special project {name}".format(name=_project_name(data, project_id)))
    else:
        data["projects"][project_id]["name"] = new_name
        msg = "Assigned new name to project {name}".format(name=_project_name(data, project_id))
        print(msg)
        save(data, msg)




#############################################################################
### Time tracking
#############################################################################

def start_tracking(project_id = None):
    """Start a tracker for a given project.

    You must specify a project id when starting a tracker. The recorded
    time will be stored in the particular project's context.
    If a tracker is alreay active, a warning will be displayed and the
    tracker will not be started.

    The optional argument project_id allows to start a new tracker
    programatically and will be used for pause/resume operations.

    :param project_id:  ID of project
    :type project_id:   str
    """
    if project_id is None and len(sys.argv) < 3:
        print("You must specify a project id")
        list_projects()
        sys.exit(20)

    data = load()
    if project_id is None:
        project_id = _get_project_id(data, sys.argv[2])

    if not project_id.isdigit():
        print("Not allowed to start tracker for special project {name}".format(name=_project_name(data, project_id)))
        sys.exit(23)

    # Check if there is an active tracker
    if data["tracking"]["active"]:
        try:
            since = data["tracking"]["started"]
            tracking_id = data["tracking"]["project"]
            _, hf, hhmm = _time_diff(since, _timestamp())
            print("Tracker already started for project {name}".format(name=_project_name(data, tracking_id)))
            sys.exit(21)
        except Exception as e:
            # We have an active tracker but it cannot be read.
            # This might happen if this tracker refers to a non-existing
            # project ID. Reset tracking settings and continue.
            print("Stopped faulty tracker marked as active: {}".format(e))
            data["tracking"]["active"] = False
            data["tracking"]["project"] = None
            data["tracking"]["started"] = None

    # Check if project ID exists
    if project_id not in data.get("projects", {}):
        print("Project {cb}{pid}{ce} not found".format(cb=bcolors.YELLOW, pid=project_id, ce=bcolors.END))
        sys.exit(12)

    data["tracking"]["active"] = True
    data["tracking"]["project"] = project_id
    data["tracking"]["started"] = _timestamp()

    msg = "Tracker started for project {name}".format(name=_project_name(data, project_id))
    print(msg)
    save(data, msg)


def stop_tracking():
    """Stop a running tracker.

    No need to specify a project id (will be ignored). If no active tracker
    is found, an error is printed to the console.
    """
    data = load()
    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    try:
        project_id = data["tracking"]["project"]

        started = data["tracking"]["started"]
        stopped = _timestamp()
        diff, hf, hhmm = _time_diff(started, stopped)

        comment = data["tracking"]["comment"]

        # add tuple to history
        history = data["projects"][project_id]["history"]
        history.append( (started, stopped, comment) )
        data["projects"][project_id]["history"] = history

        msg = "Tracker stopped for project {name} after {duration} ({hf:1.2f} hours)".format(name=_project_name(data, project_id), duration=hhmm, hf=hf)

        if comment:
            msg += ": \"{c}\"".format(c = comment)

    except Exception as e:
        # We have to deal with an entry we cannot read (and parse) correctly.
        # This might happen if the tracker refers to a non-existing project
        # ID. We should simply deactivate the tracker.
        msg = "Tracker stopped but an error occurred: {}".format(e)

    # Save the project_id as last_project (if it is a normal project)
    if project_id.isdigit():
        data["meta"]["last_project"] = project_id

    # reset tracking settings
    data["tracking"]["active"] = False
    data["tracking"]["project"] = None
    data["tracking"]["started"] = None
    data["tracking"]["comment"] = None

    print(msg)
    save(data, msg)


def cancel_tracking():
    """Cancel a tracker: Stop it and dismiss the tracked time.

    Stop the tracker, dismiss the time it has tracked and
    reset values in the tracking section of the data file.
    """
    data = load()
    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    try:
        project_id = data["tracking"]["project"]
        msg = "Tracker cancelled for project {name}".format(name = _project_name(data, project_id))

    except Exception as e:
        # We have to deal with an entry we cannot read (and parse) correctly.
        # This might happen if the tracker refers to a non-existing project
        # ID. We should simply deactivate the tracker.
        msg = "Tracker cancelled but an error occurred: {}".format(e)

    # Save the project_id as last_project (if it is a normal project)
    if project_id.isdigit():
        data["meta"]["last_project"] = project_id

    # reset tracking settings
    data["tracking"]["active"] = False
    data["tracking"]["project"] = None
    data["tracking"]["started"] = None
    data["tracking"]["comment"] = None

    print(msg)
    save(data, msg)


def switch_tracking():
    """Switch a tracker by stopping the active tracker and starting a new one.

    This function is basically an alias of "tt stop && tt start <project>".
    """
    # data = load()
    # if not data["tracking"]["active"]:
    #     print("No active tracker")
    #     sys.exit(22)

    if len(sys.argv) < 3:
        print("You must specify a project id")
        list_projects()
        sys.exit(20)

    stop_tracking()
    start_tracking()


def change_tracking():
    """Assign active tracker to new project.

    This function updates the project an already active tracker is tracking
    time in. It allows to reassign a tracker that has been started in a wrong
    project.
    """
    if len(sys.argv) < 3:
        print("You must specify a project id")
        list_projects()
        sys.exit(20)

    data = load()
    project_id = _get_project_id(data, sys.argv[2])

    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    # Change the project ID
    data["tracking"]["project"] = project_id

    msg = "Tracker changed to project {name}".format(name = _project_name(data, project_id))
    print(msg)
    save(data, msg)


def reset_tracking():
    """Reset start point to now() of an active tracker.

    This will reset the start of the tracker to the current time and
    basically resets the tracker.

    Would be the same like "tt cancel && tt start <project>".
    """
    data = load()
    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    project_id = data["tracking"]["project"]

    # Reset tracker
    data["tracking"]["started"] = _timestamp()

    msg = "Tracker resetted for project {name}".format(name=_project_name(data, project_id))
    print(msg)
    save(data, msg)


def pause_tracking():
    """Pauses a tracker.

    This function only works if tracking pause times is enabled in the local
    configuration. Otherwise this function will exit with an error code.
    If activated the current tracker will be stopped and the tracker of the
    special pause project will be started.

    The opposite of this function is resume_tracking().
    """
    if len(sys.argv) == 3:
        if sys.argv[2].lower() == "enable":
            enable_pause()
        elif sys.argv[2].lower() == "disable":
            disable_pause()
        sys.exit(0)

    data = load()

    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    if not data["config"]["log_pause_times"]:
        print("Disabled in local configuration - try \"tt stop\" instead")
        sys.exit(42)
    
    try:
        # Stop the running "normal" tracker
        project_id = data["tracking"]["project"]

        if project_id == 'p':
            print("Already paused")
            sys.exit(24)

        started = data["tracking"]["started"]
        stopped = _timestamp()
        diff, hf, hhmm = _time_diff(started, stopped)

        comment = data["tracking"]["comment"]

        # add tuple to history
        history = data["projects"][project_id]["history"]
        history.append( (started, stopped, comment) )
        data["projects"][project_id]["history"] = history

        # Start the pause tracker
        # project_id = data["meta"]["last_project"]
        data["tracking"]["active"] = True
        data["tracking"]["project"] = 'p'
        data["tracking"]["started"] = _timestamp()
        data["tracking"]["comment"] = None

        msg = "Paused tracker for project {name} after {duration} ({hf:1.2f} hours)".format(name=_project_name(data, project_id), duration=hhmm, hf=hf)

        if comment:
            msg += ": \"{c}\"".format(c = comment)

        # Save the project_id as last_project
        data["meta"]["last_project"] = project_id

        print(msg)

    except Exception as e:
        # We have to deal with an entry we cannot read (and parse) correctly.
        # This might happen if the tracker refers to a non-existing project
        # ID. We should simply deactivate the tracker.
        msg = "Error occurred while trying to pause tracker: {}".format(e)
        print(msg)

    save(data, msg)


def resume_tracking():
    """Resume a tracker.

    This function does work even if tracking of pause times is disabled.
    However, if tt is in pause mode this function will stop the tracker
    of the pause project and start the tracker of the project that has
    been paused. It's ID is saved as last_project in the meta section
    of the data file.

    If there is no running (pause) tracker this function will start a
    new timer for the project id saved as last_project in the meta
    section of the data file.
    """
    data = load()

    # If resume is called and not tracker is active, we will start a 
    # new tracker for the last project used
    if not data["tracking"]["active"]:
        start_tracking(data["meta"]["last_project"])
        sys.exit(0)

    try:
        project_id = data["tracking"]["project"]

        if project_id != 'p':
            print("No pause tracker")
            sys.exit(22)

        started = data["tracking"]["started"]
        stopped = _timestamp()
        diff, hf, hhmm = _time_diff(started, stopped)

        comment = data["tracking"]["comment"]

        # add tuple to history
        history = data["projects"]['p']["history"]
        history.append( (started, stopped) )
        data["projects"]['p']["history"] = history

        # Resume old tracker
        project_id = data["meta"]["last_project"]
        data["tracking"]["active"] = True
        data["tracking"]["project"] = project_id
        data["tracking"]["started"] = _timestamp()
        data["tracking"]["comment"] = None

        msg = "Resumed tracker for project {name} after pause of {duration} ({hf:1.2f} hours)".format(name=_project_name(data, project_id), duration=hhmm, hf=hf)

        if comment:
            msg += ": \"{c}\"".format(c = comment)

        print(msg)

    except Exception as e:
        # We have to deal with an entry we cannot read (and parse) correctly.
        # This might happen if the tracker refers to a non-existing project
        # ID. We should simply deactivate the tracker.
        msg = "Error occurred while trying to pause tracker: {}".format(e)
        print(msg)

    save(data, msg)


def add_comment():
    """Switch a tracker by stopping the active tracker and starting a new one.

    This function is basically an alias of "tt stop && tt start <project>".
    """
    # data = load()
    # if not data["tracking"]["active"]:
    #     print("No active tracker")
    #     sys.exit(22)

    data = load()

    if not data["tracking"]["active"]:
        print("No active tracker")
        sys.exit(22)

    if len(sys.argv) < 3:
        print("You must provide (at least one word as) a comment")

    comment = " ".join(sys.argv[2:]).strip()

    project_id = data["tracking"]["project"]
    data["tracking"]["comment"] = comment

    msg = "Added comment to project {name}: {comment}".format(name=_project_name(data, project_id), comment = comment)
    save(data, msg)
    print(msg)



#############################################################################
### Output
#############################################################################

def show(limit = 10):
    """Show the recorded times.

    You can specify a project ID to show only the times for this particular
    project. If you do not specify a particular project, a list of all
    recorded times will be printed to the console in the following format:
      1   LRZ
              2017-07-31      07:53 - 16:58      09:05  (9.08 hours)
              2017-08-07      07:15 - 15:22      08:07  (8.12 hours)
              2017-08-10      07:56 - 11:00      03:04  (3.07 hours)
                              11:01 - 16:46      05:45  (5.76 hours)

    If limit is specifed, only the last limit + 1 log entries are displayed
    when no project ID is given (i.e. in the overview page). If a project
    ID is given, this limit will be ignored because we assume that the user
    wants to see every detail of the particular project.

    A running tracker will displayed independently from the limit.
    limit specifies the number of "finished" log entries to display.

    The special pause project will only be displayed if tracking pause
    times is enabled in the local configuration.

    :param limit:   Number of entries to max. display per project
    :type limit:    int
    """
    data = load()
    project_ids = list() # list of project ids to display
    # first = True
    detailed_view = False

    if len(sys.argv) < 3:
        # no project ID given, get list of all available project IDs
        project_ids = sorted(list(data["projects"].keys()))
    elif len(sys.argv) >= 3:
        # project ID given, use it
        project_ids = sys.argv[2:]
        # project IDs are given, ignoring the limit
        limit = 0
        detailed_view = True
    else:
        # too many arguments, throw an error
        print("You must specify a project id")
        sys.exit(20)

    running_tracker = False
    try:
        running_tracker = data["tracking"]["active"]
        running_project = data["tracking"]["project"]
        running_since = data["tracking"]["started"]
        running_comment = data["tracking"]["comment"]
        running_since_day, running_since_time = _to_day_and_time(running_since)
    except:
        # in case of any error, set running_tracker to False
        running_tracker = False

    for raw_project_id in project_ids:
        project_id = _get_project_id(data, raw_project_id)

        # Do not display pause project if pause times should not
        # be logged
        if project_id == 'p' and not data.get("config", {}).get("log_pause_times", False):
            continue

        if project_id is None:
            # could not look up project's ID
            # inform user and continue with next ID
            print("Project {cb}{pid}{ce} not found".format(cb=bcolors.YELLOW, pid=raw_project_id, ce=bcolors.END))
            continue

        try:
            project_name = data["projects"][project_id]["name"]
            history = data["projects"][project_id]["history"]
        except KeyError as e:
            # Key (project_id) not found
            # continue with next loop run
            continue
   
        # Print the project's name
        if project_id.isdigit():
            print("    {cb}{i:>3}{ce}   {n}".format(cb=bcolors.YELLOW, i=project_id, ce=bcolors.END, n=project_name))
        else:
            print("    {cb}{i:>3}{ce}   {n}".format(cb=bcolors.BLUE, i=project_id, ce=bcolors.END, n=project_name))

        # print the history
        if len(history) == 0:
            if not running_tracker or running_project != project_id:
                # Print only if there is no currently active tracker
                # for this project
                print("              No entries")
    
        old_day = ""
        total = 0.0
        day_total = 0.0
        
        if limit and limit < len(history):
            history_to_display = history[(len(history) - limit):]
            skipped = len(history) - limit
            if skipped > 0:
                if skipped == 1:
                    txt = "1 more entry"
                else:
                    txt = "{nt} more entries".format(nt = skipped)
                
                print("              ... {t} - use \"{bin} {cmd} {pid}\" to display complete history".format(t=txt, bin=my_name, cmd=sys.argv[1], pid=project_id))
        else:
            history_to_display = history

        for item in sorted(history_to_display):
            started, stopped, comment = item
            secs, hf, hhmm = _time_diff(started, stopped)
            total = total + hf
            day, time_started = _to_day_and_time(started)
            _, time_stopped = _to_day_and_time(stopped)
            str_day = "{day:16}".format(day=day)
            if day != old_day:
                day_total = hf
                str_day_total = ""
            else:
                str_day = " "*16
                day_total = day_total + hf
                str_day_total = "{space}{dt:1.2f} hours total".format(space = " "*6, dt = day_total)

            if not comment:
                comment = ""
            else:
                # str_day_total = " "*16 + " "*6
                str_day_total += " "*(22 - len(str_day_total))
                comment = "{color}{comment}{end}".format(color = bcolors.CYAN, comment = comment, end = bcolors.END)
            
            print("              {sd}{started:5} - {stopped:11}{hhmm:7}({hf:1.2f} hours){sdt}      {c}".format(sd=str_day, started=time_started, stopped=time_stopped, hhmm=hhmm, hf=hf, sdt = str_day_total, c = comment))
            old_day = day

        if running_tracker and running_project == project_id:
            time_stopped = ""
            _, hf, hhmm = _time_diff(running_since, _timestamp())
            total = total + hf
            str_day = "{day:16}".format(day=running_since_day)
            if running_since_day == old_day:
                str_day = " "*16

            if not running_comment:
                running_comment = ""
            else:
                running_comment = "{color}{comment}{end}".format(color = bcolors.CYAN, comment = running_comment, end = bcolors.END)

            
            print("              {sd}{started:5} - {stopped:11}{hhmm:7}({hf:1.2f} hours)      tracking              {c}".format(sd=str_day, started=running_since_time, stopped=time_stopped, hhmm=hhmm, hf=hf, c = running_comment))

        if detailed_view:
            print("              Total time tracked: {hf:9.2f} hours".format(project=_project_name(data, project_id=project_id), hf=total))
            


#############################################################################
### Entry point
#############################################################################

"""Main function/entry point when starting the program.

Parses the arguments and calls the appropriate functions.
"""

if len(sys.argv) <= 1:
    status()
    sys.exit(0)

cmd = parse_command(sys.argv[1].lower())

if cmd == "init":
    init()
elif cmd == "status":
    status()
elif cmd == "log":
    print_log()
elif cmd == "cleanup":
    cleanup()

elif cmd == "aliases":
    print_aliases()
elif cmd == "alias":
    alias()
elif cmd == "unalias":
    unalias()

elif cmd == "list":
    list_projects()
elif cmd == "add":
    add_project()
elif cmd == "delete":
    del_project()
elif cmd == "rename":
    rename_project()
elif cmd == "show":
    show()

elif cmd == "pause":
    pause_tracking()
elif cmd == "resume":
    resume_tracking()
elif cmd == "start":
    start_tracking()
elif cmd == "stop":
    stop_tracking()
elif cmd == "switch":
    switch_tracking()
elif cmd == "change":
    change_tracking()
elif cmd == "cancel":
    cancel_tracking()
elif cmd == "reset":
    reset_tracking()
elif cmd == "comment":
    add_comment()


else:
    usage()

# EOF