#!/usr/bin/env python3
# This is a script intended to track your project activities.
# It is really simple and I got the idea when using todolist on the command
# line. tymetracker (tt) is written entirely in Python 3 and stores the
# records in a json data structure in the user's home directory.
#
# Exit codes
# There are a couple of exit codes that can occur when running tt.
# Code  Meaning
# -----+---------------------------------------------------------------------
#    0  OK
#    1  Python Version < 3.x
#    2  Data file should be initialized but does already exist
#    3  Data file not found
#    4  Other exception while trying to read data file
#    5  Could not read data from data file
#    6  Could not import required python module
#    7  Exception while saving/writing data to data file
#   10  Project's name or ID not specified when trying to add a new project
#   11  Project's name or ID not specified
#   12  Project with given name or ID could not be found
#   13  Not allowed to alter special project
#   14  Default project not set
#   20  Project's name or ID not specified when trying to start tracker
#   21  Tracker already started
#   22  No tracker found
#   23  Not allowed to start or stop tracker for special project
#   24  Tracker already paused
#   30  Alias or command not specified when adding alias
#   31  Invalid command when trying to add alias
#   32  Alias not found
#   42  Disabled in local configuration
#   50  No comment given

# Import stuff we need
import copy
import datetime
import json
import os
import sys

#############################################################################
### Here be dragons!
#############################################################################
class TymeTracker:
    datafile = "~/.tt.json"
    dateformat = "%Y-%m-%dT%H:%M:%S"


    # This variable defines the format version of the datafile
    DATAFILE_VERSION = 6

    # Set variables we need
    f = os.path.abspath(os.path.expanduser(datafile))
    my_name = os.path.basename(sys.argv[0])

    # Cache for data
    DATA = None



    #############################################################################
    ### Helper functions
    #############################################################################

    def _get_project_id(self,
            data: dict,
            project_id_or_name: str,
            ) -> str:
        """Look up and return a project's ID if it exists.

        If the project ID is given, this ID will be returned if the project
        exists in the data. If a project's name is given, this function
        looks up the name in data and return the ID of the project.
        If the project could not be found, this function returns None.

        :param data:                Data object representing the current state
        :type data:                 dict
        :param project_id_or_name:  Argument given by caller representing either a project ID or name
        :type project_id_or_name:   str
        :return:                    ID of the project in the data object
        :rtype:                     str
        """
        pin = None
        if isinstance(project_id_or_name, str):
            pin = project_id_or_name
        elif isinstance(project_id_or_name, list):
            pin = " ".join(project_id_or_name)
        else:
            print(f"Could not look up project ID for {project_id_or_name} ({type(project_id_or_name)})")
            return None


        # If we have a positive number project_id_or_name could be the
        # ID itself. Let's check
        if pin.isdigit() or pin in ['p']:
            if pin in data["projects"].keys():
                # return project_id_or_name
                return pin

        # project_id_or_name is not the project ID. Let's search all projects'
        # names
        for project_id, project in data["projects"].items():
            if pin == project["name"]:
                return project_id

        # Ok, did not find anything yet. Maybe the case of the letters is
        # different... since we found nothing yet, let's try that.
        # Note, that case-removing conversions in unicode aren't trivial. There
        # is text for which text.lower() != text.upper().lower(), such as "ß":
        #  "ß".lower()
        #  #>>> 'ß'
        #  "ß".upper().lower()
        #  #>>> 'ss'
        for project_id, project in data["projects"].items():
            if pin.lower() == project["name"].lower():
                return project_id

        # We could not find the string neither in the IDs nor in the names.
        # Giving up.
        print(f"Project {bcolors.YELLOW}{project_id_or_name}{bcolors.END} not found")
        sys.exit(12)

        return None


    def _get_list_of_project_ids(self,
            only_numeric: bool = False,
            ):
        """Get a list of all existing project IDs.

        :param only_numeric:    Return only numeric IDs (== normal projects)
        :type only_numeric:     bool
        :return:                All assigned project IDs
        :rtype:                 list of str (!)
        """
        data = self.load()
        all_project_ids = list(data["projects"].keys())
        result = []

        if not only_numeric:
            result = all_project_ids
        else:
            for i in all_project_ids:
                try:
                    int(i)
                    result.append(i)
                except:
                    continue

        return result


    def _get_project_name(self,
            data: dict,
            project_id: str,
            ) -> str:
        """Return the name of a project.

        Get a project's name. Consider using _project_name() function below if
        you need to display the project's name in-line.

        :param data:        Data object representing the current state
        :type data:         dict
        :param project_id:  ID of project
        :type project_id:   str
        :return:            Name of the project
        :rtype:             str
        """
        try:
            return data["projects"][project_id]["name"]
        except:
            return None


    def _project_name(self,
            data: dict,
            project_id: str,
            ) -> str:
        """Return a colored string representing a project.

        Returns a string that can be used every time when a project's name needs
        do be displayed. Using this function makes sure that the name is always
        printed in the same way making it easier to use tt.

        :param data:        Data object representing the current state
        :type data:         dict
        :param project_id:  ID of project
        :type project_id:   str
        :return:            Colored string to print on the command line
        :rtype:             str or None
        """
        pname = self._get_project_name(data, project_id)

        is_numeric = project_id in self._get_list_of_project_ids(only_numeric = True)

        if pname is not None:
            if is_numeric:
                r = f"{bcolors.YELLOW}{project_id}{bcolors.END}: \"{pname}\""
            else:
                r = f"{bcolors.BLUE}{project_id}{bcolors.END}: \"{pname}\""
        else:
            r = None

        return r


    def _timestamp(self) -> str:
        """Return a timestamp.

        This timestamp is crucial since it is used in the JSON file to store
        the beginning and end of the the time periods.
        We use the ISO format to ensure that humans can read (and modify) the
        values manually if needed.

        :return:    Return a timestamp used to calculate tracking times
        :rtype:     str
        """
        return datetime.datetime.now().strftime(self.dateformat)

    def _get_trackings(self,
            data: dict,
            project_id: str = None,
            date_prefix = None,
            ) -> dict:
        """Return the tracked time slots.

        If neither project_id or date_prefix are given the returned dict
        will contain all tracked times for all projects.

        Specifying a project_id will limit the returned times to this
        particular project.

        Specifying a date_prefix will filter limit the returned times to
        slots whose start times match the date_prefix.
        A start time of a tracked slot looks like this:
            2021-04-06T13:16:31
        You you want only the trackings for a given day,
        i.e. the 6th of April 2021, you can use the date_prefix "2021-04-06".
        If you want the trackings for April 2021, you can use the date_prefix
        "2021-04".
        You can also define mulitple date_prefixes by providing a list of strs.
        The function uses Python's built-in string-function .startswith() to
        compare the date_prefix with the slots' start time.

        The returned results dict contains the project ID(s) as key(s) and
        the tracked times as values. Each value is a list of 3-tuples
        representing (start_time, stop_time, comment).
        Even if you limit the project_id the result have this project ID as
        key and the corresponding tracked times (maybe filtered by  date_prefix)
        as value.

        :param data:        Data object representing the current state
        :type data:         dict
        :param project_id:  ID of project to get the tracked times for
        :type project_id:   str or None
        :param date_prefix: A (list of) date prefix(es) used as filter to limit tracked times
        :type date_prefix:  str, list or None
        :return:            Dict with project IDs as key and list of tracked times as value
        :rtype:             dict
        """
        result = {}
        all_trackings = data.get("projects", {})

        # First, gather the trackings for all projects
        for pid, pdata in all_trackings.items():
            result[pid] = pdata.get("history", [])

        # Second, if project_id is not None, reduce the result to this
        # project's trackings
        if project_id is not None:
            pid = self._get_project_id(data, project_id)
            pids_to_delete = []
            for existing_pid in result.keys():
                if existing_pid != pid:
                    pids_to_delete.append(existing_pid)

            for ptd in pids_to_delete:
                del(result[ptd])

        # Third, if time should be limited to some particular prefix
        # delete all trackings not started at this prefix
        if date_prefix is not None:
            # If date_prefix is of type str we create a list containig this
            # str. We need a list since we will iterate over its elements
            # a few lines below
            if type(date_prefix) == str:
                date_prefix = [date_prefix]

            new_result = {}
            for dp in date_prefix:
                trackings = []
                for pid, pdata in result.items():
                    pid_trackings = new_result.get(pid, [])

                    new_trackings = [tracking for tracking in pdata if tracking[0].startswith(dp)]
                    for t in new_trackings:
                        pid_trackings.append(t)

                    new_result[pid] = pid_trackings

            result = new_result

        # Lastly, return the result
        return result

    def _convert_seconds_to_hf(self,
            seconds: float,
            ) -> float:
        """Convert seconds to fractions of hours.

        This function is used when displaying the tracked time in hours
        format like 8,25 hours (which represents 29700 seconds).

        :param seconds: Number of seconds
        :type seconds:  float
        :return:        Decimal number representing the hours
        :rtype:         float
        """
        return seconds / 3600

    def _convert_seconds_to_hhmm(self,
            seconds: float,
            ) -> str:
        """Convert seconds to hh:mm format.

        This function is used when displaying the tracked time in hhmm format
        like 08:15 (which represents 29700 seconds).

        :param seconds: Number of seconds
        :type seconds:  float
        :return:        String in hh:mm format
        :rtype:         str
        """
        return "{h:02.0f}:{m:02.0f}".format(h=seconds//3600, m=(seconds//60)%60)

    def _time_diff(self,
            started: str,
            stopped: str,
            ) -> tuple:
        """
        Calculate the difference between to datetimes.
        Returns a 3-tuple containing
            seconds as float (e.g., 23132.0 seconds)
            hour_frac as float (e.g., 0.3455353 hours)
            hhmm as string (e.g., 01:23)

        :param started: Start time
        :type started:  str
        :param stopped: Stop time
        :type stopped:  str
        :return:        3-tuple with (seconds, hf, hhmm)
        :rtype:         (float, float, str)
        """
        a = datetime.datetime.strptime(started, self.dateformat)
        b = datetime.datetime.strptime(stopped, self.dateformat)
        c = b - a
        seconds = c.total_seconds()
        hour_frac = self._convert_seconds_to_hf(seconds)
        hhmm = self._convert_seconds_to_hhmm(seconds)

        # return tuple
        return (seconds, hour_frac, hhmm)


    def _to_day_and_time(self,
            isodateformat: str,
            ) -> tuple:
        """
        Return the day and the time from an ISO-formatted date.
        Given a timestamp, the day and the time will be returned as a 2-tuple with
        the day in format YYYY-mm-dd as first element and the time in format HH:MM
        as the second element of the tuple.

        :param isodateformat:   Time to return in ISO format
        :type isodateformat:    str
        :return:                2-tuple with (day, time), i.e. ("2021-04-07", "10:04")
        :rtype:                 (str, str)
        """
        day = datetime.datetime.strptime(isodateformat, self.dateformat).strftime('%Y-%m-%d')
        time = datetime.datetime.strptime(isodateformat, self.dateformat).strftime('%H:%M')
        return (day, time)



    #############################################################################
    ### Configuration functions
    #############################################################################


    def enable_log(self) -> None:
        """Enable log functionality.

        This function reconfigures and saves the particular setting in the
        data files's config section.
        """
        data = self.load()
        if not data["config"]["log_actions"]:
            msg = "Enabled log"
            data["config"]["log_actions"] = True
            print(msg)
            self.save(data, msg)
        else:
            print("Log already enabled")


    def disable_log(self) -> None:
        """Disable log functionality.

        This function reconfigures and saves the particular setting in the
        data files's config section.
        """
        data = self.load()
        if data["config"]["log_actions"]:
            msg = "Disabled log"
            data["config"]["log_actions"] = False
            print(msg)
            self.save(data, msg)
        else:
            print("Log already disabled")


    def enable_pause(self) -> None:
        """Enable tracking pause times.

        This function reconfigures and saves the particular setting in the
        data files's config section.
        """
        data = self.load()
        if not data["config"]["log_pause_times"]:
            msg = "Enabled tracking of pause times"
            data["config"]["log_pause_times"] = True
            print(msg)
            self.save(data, msg)
        else:
            print("Tracking of pause times already enabled")


    def disable_pause(self) -> None:
        """Disable tracking pause times.

        This function reconfigures and saves the particular setting in the
        data files's config section.
        """
        data = self.load()
        if data["config"]["log_pause_times"]:
            msg = "Disabled tracking of pause times"
            data["config"]["log_pause_times"] = False
            print(msg)
            self.save(data, msg)
        else:
            print("Tracking of pause times already disabled")



    #############################################################################
    ### Data file functions
    #############################################################################

    def load(self) -> dict:
        """Load data file contents.

        Load the JSON datafile and return a dict with all the values.

        :return:    Data object representing the current state
        :rtype:     dict
        """
        f = self.f

        if self.DATA:
            return self.DATA

        try:
            fp = open(f, "r")
            data = json.load(fp)
            fp.close()
        except FileNotFoundError as e:
            print(f"Could not load data file. Please run {bcolors.YELLOW}init{bcolors.END} first.")
            sys.exit(3)
        except Exception as e:
            print(e)
            sys.exit(4)

        if data is None:
            print(f"Read corrupt data from {f}")
            sys.exit(5)

        # Apply upgrade to the data read from the disk (if needed)
        data = self._file_version_upgrade(data)
        self.DATA = data

        return data


    def save(self,
            data: dict,
            msg: str = None,
            ) -> None:
        """Write the data dict object to disk in JSON format.

        If a msg is set, this text will be appended to the log in the datafile
        if logging in the config section is set to True (which is the default).

        :param data:    Data object representing the current state
        :type data:     dict
        :param msg:     ID of project
        :type msg:      str
        """
        f = self.f

        if data is not None:
            if msg is not None and data.get("config", {}).get("log_actions", False):
                data.get("log", []).append(f"{self._timestamp().replace('T', ' ')}  {msg}")

            global DATA
            DATA = data

            try:
                fp = open(f, "w")
                json.dump(data, fp, indent=2)
                fp.flush()
                fp.close()
            except Exception as e:
                print(e)
                sys.exit(7)
        else:
            print("No data to write")


    def _file_version_upgrade(self,
            data: dict = None,
            ) -> dict:
        """This function migrates a data file from on old version to a new version.

        If the data object is given as an argument, this function will operate on
        the provided data object otherwise the data will be loaded from disk.
        The version of the data file and the version needed by tt will be
        compared. If needed, modifications are applied to the data object.
        After applying all modifications the data object is stored to disk and
        is returned by this function.

        :param data:    (Optional) Data object representing the current state
        :type data:     dict
        :return:        Return updated data object
        :rtype:         dict
        """
        # Load the data from the datafile on disk (if needed)
        if data is None:
            data = load()

        # Determine the version of the data file as well as the version
        # we need to migrate to
        from_version = int(data["meta"]["file_version"])
        to_version = int(self.DATAFILE_VERSION)

        # Check if changes need to be made, otherwise return data object
        if from_version >= to_version:
            return data

        current_version = from_version
        while current_version < to_version:
            if current_version == 1:
                # This first upgrade changes the data structure significantly
                # and introduces some new features:
                #   1.  Keep track of the last project used. This allows to
                #       support the "resume" command
                #   2.  Support for logging pause times. There is now a
                #       special project "p"/"Pause" where these times are
                #       tracked
                #   3.  Support to log actions
                data["meta"]["file_version"] = 2
                data["meta"]["last_project"] = None
                data["config"] = {
                        "log_pause_times": True,
                        "log_actions": True,
                        }
                # This is the special project "Pause".
                # This project is used for pause/resume timekeeping.
                data["projects"]["p"] = {
                        "name": "Pause",
                        "history": []
                        }
                data["log"] = []

            if current_version == 2:
                # The upgrade from version 2 introduces support for comments
                data["meta"]["file_version"] = 3
                data["tracking"]["comment"] = None  # Comments are stored here (as str)

                for project_id, project_data in data["projects"].items():

                    # We need to build a new history for every project
                    # The old history contains 2-tuples with the start time
                    # and the end time of the tracker, the new history
                    # is a 3-tuple conainting an additional string
                    # representing a comment regarding this stint.
                    # This comment is None by default.
                    old_history = project_data["history"]
                    new_history = []

                    for (start_tracking, end_tracking) in old_history:
                        new_tuple = (start_tracking, end_tracking, None)
                        new_history.append(new_tuple)

                    data["projects"][project_id]["history"] = new_history

            if current_version == 3:
                # This update from version 3 to version 4 introduces support
                # for user defined alias commands
                data["meta"]["file_version"] = 4
                data["aliases"] = {
                        "st": "status",
                        "a": "add",
                        "d": "delete",
                        "l": "list",
                        "ch": "change",
                        "c": "comment",
                        "p": "pause",
                        "r": "resume",
                        "s": "show",
                        "sw": "switch",
                        }

            if current_version == 4:
                # This version fixes a problem with the data file.
                # We had a problem in the resume_tracking() function that
                # prevented the comment from being written to the pause project's
                # history. This would case an error when show() is called.
                data["meta"]["file_version"] = 5

                # We need to rebuild the history again.
                # This time, only the pause project (ID: p) is affected.

                # Old comments have not been written when the project is paused
                # therefore this information has been lost earlier. We will set
                # the comment value to None.
                old_history = data["projects"]["p"]["history"]
                new_history = []

                for (start_tracking, end_tracking) in old_history:
                    new_tuple = (start_tracking, end_tracking, None)
                    new_history.append(new_tuple)

                data["projects"]["p"]["history"] = new_history

            if current_version == 5:
                # The upgrade from version 5 to version 6 introduces the
                # default_project setting in the meta section of the data
                # file allowing to just use "tt start" to track times for
                # this default project - if set
                data["meta"]["file_version"] = 6

                data["meta"]["default_project"] = None

            # increment current_version to carry out next update if needed
            current_version += 1

        msg = f"Converted data file format from version {from_version} to version {to_version}"
        self.save(data, msg)
        print(msg)

        # Return upgraded data object
        return data



    #############################################################################
    ### Generic functions
    #############################################################################

    def init(self) -> None:
        """Initialize a new datafile if it does not exist.

        If a data file already exists, the program will return with an error code.
        If an existing data file should be overwritten, the user needs to
        manually delete the existing file.

        The new data file will be written to disk and the program will exit.
        """
        f = self.f

        if os.path.isfile(f):
            print(f"Data file {f} already exists")
            sys.exit(2)
        else:
            print(f"Initializing new data file {f}")

            # Initialize new data dict
            # For sake of simplicity we create a very basic structure here
            # representing the original first version of the data file.
            # Afterwards we manually call self._file_version_upgrade() to
            # update the structure to the latest data file version.

            data = {
                    "meta": {
                        "last_id": 0,
                        "file_version": 1,
                        },
                    "tracking": {
                        "active": False,
                        "project": None,
                        "started": None,
                        "comment": None,
                        },
                    "projects": {
                        # id:    {
                            # "name": Projektname,
                            # "history": [] # elements are tuples (start, stop)
                        # }
                        # },
                    }
                    }

            # ... convert it to the newest version
            data = self._file_version_upgrade(data)

            # ... and write it to data file
            self.save(data, "Initialized new data file")


    def status(self) -> None:
        """Print current state.

        If a tracker is active this function displays a brief summary of the
        recent work period.
        """
        data = self.load()

        if not data["tracking"]["active"]:
            print("No active time tracking")
        else:
            since = data["tracking"]["started"]
            project_id = data["tracking"]["project"]
            comment = data["tracking"]["comment"]
            active_seconds, hf, hhmm = self._time_diff(since, self._timestamp())

            msg = f"Currently tracking time in project {self._project_name(data, project_id)} for {hhmm} ({hf:0.2f} hours)"
            if comment:
                msg += f": \"{comment}\""
            print(msg)


            # Time tracked today in this particular project
            # only if there is something additional to display
            today, _ = self._to_day_and_time(self._timestamp())
            today_slots_in_project = self._get_trackings(data, project_id, today)
            today_slots = today_slots_in_project.get(project_id, [])
            if len(today_slots):
                seconds = active_seconds
                for tracking in today_slots:
                    start, stop, comment = tracking
                    s, _, _ = self._time_diff(start, stop)
                    seconds += s

                hf = self._convert_seconds_to_hf(seconds)
                hhmm = self._convert_seconds_to_hhmm(seconds)

                print(f"Total time tracked today in project {self._project_name(data, project_id)} is {hhmm} ({hf:0.2f} hours)")


    def print_log(self,
            limit: int = 20,
            ) -> None:
        """Print log.

        If the log is enabled in the local configuration existing log entries
        are printed to the console.
        The user can also privde "enable", "disable", or a number as argument
        together with the log keyword. If enable or disable is given, the
        appropriate configuration update is carried out. If a number is given
        this number is treated as the number of log entries to print.
        """
        if len(sys.argv) == 3:
            if sys.argv[2].lower() == "enable":
                self.enable_log()
                sys.exit(0)
            elif sys.argv[2].lower() == "disable":
                self.disable_log()
                sys.exit(0)
            elif sys.argv[2].isdigit():
                # Display last n entries
                limit = int(sys.argv[2])

        data = self.load()
        if not data["config"]["log_actions"]:
            print("Disabled in local config")
            sys.exit(42)

        # Get the last limit entries of the list of log entries
        history = data["log"][-limit:]

        # Print the log
        for line in history:
            print(f"{' ' * 2}{line}")


    def cleanup(self) -> None:
        """Clean up the projects.

        This function will reassign new IDs to the project.
        After the reorganization the file is saved to disk.
        """
        data = self.load()

        # iterate the projects and reassign new IDs
        old_projects = copy.deepcopy(data["projects"])
        project_id = 0
        data["projects"] = {}
        for old_pid, project in old_projects.items():
            if old_pid == "p":
                data["projects"]["p"] = project
            else:
                project_id = project_id + 1
                data["projects"][project_id] = project

        # set the correct last ID
        data["meta"]["last_id"] = project_id

        # write to disk
        self.save(data, "Cleaned up data file")
        print(f"Successfully cleaned up {self.datafile}")


    def parse_command(self,
            command_or_alias: str,
            ) -> str:
        """Returns the name of a command (for an alias if defined).

        The data file allows aliases to be defined to shorten commands the user
        needs to type in.
        This function returns the full command for a given alias if this
        alias exists in the data file.
        If the complete function name is given in the alias attribute and
        such a command exists, this name will also be returned.

        :return:    Command name that should be carried out
        :rtype:     str or None
        """
        data = self.load()
        commands = self.get_commands()

        if command_or_alias in commands:
            return command_or_alias
        else:
            resolved_alias = data.get("aliases", {}).get(command_or_alias, None)
            if resolved_alias and resolved_alias in commands:
                return resolved_alias

        return None



    def get_command_groups(self) -> dict:
        """Defines the commands and the groups where they belong.

        The dict that will be returned contains other dictionaries, each
        representing a group of commands. These dictionaries can contain
        a reserved key DESC that provides a human-readable short description
        of this command group.

        :return:    Group of commands used to display the help message
        :rtype:     dict of dicts
        """
        group = {
                "Generic commands": {
                    "DESC": f"Commands to initialize {self.my_name} and perform management tasks.",
                    "init": "Initialize new data file",
                    "status": "Display tracker status information",
                    "cleanup": "Cleanup and reorganize data file",
                    "log": "Show activity log",
                    "log enable": "Enable activity log",
                    "log disable": "Disable activity log",
                    "aliases": "Shows list of all defined aliases",
                    "alias a command": "Create or updates alias a for a particular command",
                    "unalias a": "Remove alias a",
                    },
                "Projects": {
                    "DESC": "Before you can start a tracker you need to create a project to which this tracker is assigned. These commands allow you to add, delete and manage existing projects.",
                    "add project name": "Add new project with name \"project name\"",
                    "default 23": "Set project with id 23 as default project",
                    "delete 23": "Delete project with id 23",
                    "list": "List projects and their ids",
                    "rename 23 new name": "Rename project with ID 23 to \"new name\"",
                    "undefault": "Unset the current default project settings",
                    },
                "Tracking": {
                    "DESC": "These commands allow to start and stop trackers as well as displaying tracked times in existing projects.",
                    "start 23": "Start time tracking for project id 23",
                    "stop": "Stop active time tracking",
                    "pause": "Pause an active tracker",
                    "pause add 30-50 23 2019-03-14T09:46:26":  "Add a pause of a random duration between 30 and 50 minutes to the project 23's time period started on 2019-03-14 09:46:26",
                    "pause disable": "Disable tracking of pause times",
                    "pause enable": "Enable tracking of pause times",
                    "resume": "Resume tracker from paused project or from last project used",
                    "switch 23": "Switch a tracker to a new project by stopping it and starting a new",
                    "change 23": "Chance project assigned to an active tracker",
                    "cancel": "Cancel active tracker and dismiss time",
                    "reset": "Reset time of active tracker",
                    "comment comment": "Add \"comment\" to the current active tracker",
                    },
                "Summarizing": {
                    "DESC": "These commands display the time tracked in different ways.",
                    "csv 23": "Show tracked times as CSV",
                    "show": "Show tracked times for all projects",
                    "show 23": "Show tracked times and some additional information for project 23",
                    "tab 23": "Show tracked times in a pretty table format",
                    "week": "Show a report of the time tracked in the current week",
                    "week 23": "Show the time tracked for project 23 in the current week",
                    }
                }

        dict_of_aliases = self.get_aliases()
        if len(dict_of_aliases):
            dict_of_aliases["DESC"] = "Aliases defined in the data file"
            group["Aliases"] = dict_of_aliases

        return group


    def get_commands(self) -> set:
        """Returns a set of all commands available by this version of tt.

        This set does not contain aliases defined in the data file but only
        full commands. It will be used for input parsing.

        :return:    All commands available to the user
        :rtype:     Set of strings
        """
        groups = self.get_command_groups()
        result = set()

        for group_name, group in groups.items():
            if group_name != "Aliases":
                for command in group.keys():
                    if command != "DESC":
                        result.add(command.split(" ")[0])

        return result




    def usage(self) -> None:
        """Print the list of commands that are supported.

        This function is called everytime  the user calls tt with no or too
        few arguments.
        """
        group = self.get_command_groups()

        # Display the commands/dicts
        first = True
        for group, commands in group.items():
            if first:
                first = False
            else:
                print("\n")
            print(f"{bcolors.PURPLE}{group}{bcolors.END}")

            # print the DESC if needed
            if "DESC" in commands:
                print(f"     {commands['DESC']}\n")

            # print all commands (and not DESC)
            for command, description in sorted(commands.items()):
                if command != "DESC":
                    print(f"{bcolors.YELLOW}{command:20s}{bcolors.END} {description}")



    def get_aliases(self) -> dict:
        """Return a dict containing all aliases defined.

        Key is the alias, value is the command to call.

        :return:    All defined aliases
        :rtype:     dict
        """
        data = self.load()
        aliases = data.get("aliases", {})

        dict_of_aliases = {}
        if len(aliases) > 0:

            for alias, command in aliases.items():
                dict_of_aliases[alias] = command

        return dict_of_aliases



    def print_aliases(self) -> None:
        """Print list of defined aliases.
        """
        aliases = self.get_aliases()
        for alias, command in sorted(aliases.items()):
            print(f"{alias:>4}    {command}")


    def alias(self) -> None:
        """Add or update an alias for a particular command.

        The alias will only be added to the data file if a valid command is
        specified.
        """
        if len(sys.argv) < 4:
            print("You must specify alias and command")
            sys.exit(30)

        data = self.load()
        alias = sys.argv[2]
        command = sys.argv[3]

        if command in self.get_commands():
            data["aliases"][alias] = command
            msg = f"Created alias {alias} for command {command}"
            self.save(data, msg)
            print(msg)
        else:
            print(f"Could not create alias {alias} for {command}: Invalid command")
            sys.exit(31)


    def unalias(self) -> None:
        """Removes alias from the data file.
        """
        if len(sys.argv) < 3:
            print("You must specify alias to remove")
            sys.exit(30)

        data = self.load()
        alias = sys.argv[2]

        if alias in data["aliases"].keys():
            msg = f"Removed alias {alias} for {data['aliases'][alias]}"
            del data["aliases"][alias]
            self.save(data, msg)
            print(msg)
        else:
            print("Alias {alias} not defined")
            sys.exit(32)


    #############################################################################
    ### Projects
    #############################################################################

    def list_projects(self) -> None:
        """Print all existing projects.

        The special project p is only displayed if tracking pause times is enabled
        in the local configuration.
        """
        data = self.load()
        p = data.get("projects", {})
        show_pause_project = data.get("config", {}).get("log_pause_times", False)

        if len(p) == 0:
            print("No projects found.")
        else:
            for project_id, project_data in sorted(p.items()):
                if project_id == "p" and not show_pause_project:
                    continue

                if project_id == data["meta"]["default_project"]:
                    is_default = f"{bcolors.CYAN}D{bcolors.END}"
                else:
                    is_default = " "

                if project_id.isdigit():
                    print(f"   {is_default} {bcolors.YELLOW}{project_id:>3}{bcolors.END}   {project_data['name']}")
                else:
                    print(f"   {is_default} {bcolors.BLUE}{project_id:>3}{bcolors.END}   {project_data['name']}")


    def add_project(self) -> None:
        """Add a project.

        You need to specify a project name. The project name can contain spaces.
        When created, this function prints the id of the created project.
        """
        if len(sys.argv) < 3:
            print("You must specify a project name")
            sys.exit(10)

        name = " ".join(sys.argv[2:]).strip()

        data = self.load()
        project = {}
        project_id = int(data["meta"].get("last_id", 0)) + 1

        # If there is a bogus last_id in our file, we need to make sure that no
        # existing data will be overwritten

        existing_project_ids = self._get_list_of_project_ids(only_numeric = True)
        if project_id in existing_project_ids:
            # Get the biggest existing project ID and increase it by 1
            project_id = max(existing_project_ids) + 1

        project["name"] = name
        project["history"] = []

        projects = data.get("projects", {})
        projects[project_id] = project

        data["meta"]["last_id"] = project_id
        data["projects"] = projects

        msg = f"Created project {self._project_name(data, project_id)}"
        self.save(data, msg)
        print(msg)


    def delete_project(self) -> None:
        """Delete a project.

        You need to specify a project id.
        """
        if len(sys.argv) < 3:
            print("You must specify a project id")
            list_projects()
            sys.exit(11)

        data = self.load()
        project_id = self._get_project_id(data, sys.argv[2:])

        if project_id not in data.get("projects", {}).keys():
            print(f"Project {bcolors.YELLOW}{project_id}{bcolors.END} not found")
            sys.exit(12)
        elif not project_id.isdigit():
            print(f"Not allowed to delete special project {self._project_name(data, project_id)}")
        else:
            msg = f"Project {self._project_name(data, project_id)} deleted"
            del data["projects"][project_id]
            print(msg)
            self.save(data, msg)


    def rename_project(self) -> None:
        """Rename a project.

        You need to specify a project id and a new project name.
        """
        if len(sys.argv) < 4:
            print("You must specify a project id and a new project name")
            self.list_projects()
            sys.exit(11)

        project_id = sys.argv[2]
        new_name = " ".join(sys.argv[3:])

        data = self.load()
        if project_id not in data.get("projects", {}):
            print(f"Project {bcolors.YELLOW}{project_id}{bcolors.END} not found")
            sys.exit(12)
        elif not project_id.isdigit():
            print(f"Not allowed to rename special project {self._project_name(data, project_id)}")
        else:
            data["projects"][project_id]["name"] = new_name
            msg = f"Assigned new name to project {self._project_name(data, project_id)}"
            print(msg)
            self.save(data, msg)


    def set_default_project(self) -> None:
        """This function sets a project as default project.

        This allows the use of "tt start" without specifying a project
        number: If no project number is specified and a default_project is
        set time will be tracked for this project.
        """
        if len(sys.argv) < 3:
            print("You must specify a project id or project name")
            self.list_projects()
            sys.exit(11)

        data = self.load()
        project_id = self._get_project_id(data, sys.argv[2])

        if project_id not in data.get("projects", {}):
            print(f"Project {bcolors.YELLOW}{project_id}{bcolors.END} not found")
            sys.exit(12)
        elif not project_id.isdigit():
            print(f"Not allowed to set special project {self._project_name(data, project_id)} as default project")
        else:
            data["meta"]["default_project"] = project_id
            msg = f"Set project {self._project_name(data, project_id)} as default project"
            print(msg)
            self.save(data, msg)


    def unset_default_project(self) -> None:
        """This function sets th default_project setting in the meta section
        of the data file to None meaning that there will be not default
        project afterwars.
        """
        data = self.load()
        default_project = data["meta"]["default_project"]
        if default_project is None:
            print("No default project set")
        else:
            data["meta"]["default_project"] = None
            msg = f"Removed {self._project_name(data, default_project)} as default project"
            print(msg)
            self.save(data, msg)


    #############################################################################
    ### Time tracking
    #############################################################################

    def start_tracking(self,
            project_id: str = None,
            ):
        """Start a tracker for a given project.

        You must specify a project id when starting a tracker. The recorded
        time will be stored in the particular project's context.
        If a tracker is alreay active, a warning will be displayed and the
        tracker will not be started.

        The optional argument project_id allows to start a new tracker
        programatically and will be used for pause/resume operations.

        :param project_id:  ID of project
        :type project_id:   str
        """
        data = self.load()

        if len(sys.argv) < 3:
            # We did not receive a project ID from the command line
            if data["meta"]["default_project"] is None:
                print("You must specify a project id or set a default project")
                self.list_projects()
                sys.exit(20)
            else:
                project_id = data["meta"]["default_project"]
        else:
            # Take the received argument as project ID regardless of the
            # default_project set in the meta section of the data file.
            # This allows to track times for other projects as well. :)
            project_id = self._get_project_id(data, sys.argv[2])

        if not project_id.isdigit():
            print(f"Not allowed to start tracker for special project {self._project_name(data, project_id)}")
            sys.exit(23)

        # Check if there is an active tracker
        if data["tracking"]["active"]:
            try:
                since = data["tracking"]["started"]
                tracking_id = data["tracking"]["project"]
                _, hf, hhmm = self._time_diff(since, self._timestamp())
                print(f"Tracker already started for project {self._project_name(data, tracking_id)}")
                sys.exit(21)
            except Exception as e:
                # We have an active tracker but it cannot be read.
                # This might happen if this tracker refers to a non-existing
                # project ID. Reset tracking settings and continue.
                print(f"Stopped faulty tracker marked as active: {e}")
                data["tracking"]["active"] = False
                data["tracking"]["project"] = None
                data["tracking"]["started"] = None

        # Check if project ID exists
        if project_id not in data.get("projects", {}):
            print(f"Project {bcolors.YELLOW}{project_id}{bcolors.END} not found")
            sys.exit(12)

        data["tracking"]["active"] = True
        data["tracking"]["project"] = project_id
        data["tracking"]["started"] = self._timestamp()

        msg = f"Tracker started for project {self._project_name(data, project_id)}"
        print(msg)
        self.save(data, msg)

    def stop_tracking(self) -> None:
        """Stop a running tracker.

        No need to specify a project id (will be ignored). If no active tracker
        is found, an error is printed to the console.
        """
        data = self.load()
        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        try:
            project_id = data["tracking"]["project"]

            started = data["tracking"]["started"]
            stopped = self._timestamp()
            diff, hf, hhmm = self._time_diff(started, stopped)

            comment = data["tracking"]["comment"]

            # add tuple to history
            history = data["projects"][project_id]["history"]
            history.append( (started, stopped, comment) )
            data["projects"][project_id]["history"] = history

            msg = f"Tracker stopped for project {self._project_name(data, project_id)} after {hhmm} ({hf:1.2f} hours)"

            if comment:
                msg += f": \"{comment}\""

        except Exception as e:
            # We have to deal with an entry we cannot read (and parse) correctly.
            # This might happen if the tracker refers to a non-existing project
            # ID. We should simply deactivate the tracker.
            msg = f"Tracker stopped but an error occurred: {e}".format(e)

        # Save the project_id as last_project (if it is a normal project)
        if project_id.isdigit():
            data["meta"]["last_project"] = project_id

        # reset tracking settings
        data["tracking"]["active"] = False
        data["tracking"]["project"] = None
        data["tracking"]["started"] = None
        data["tracking"]["comment"] = None

        print(msg)
        self.save(data, msg)


    def cancel_tracking(self) -> None:
        """Cancel a tracker: Stop it and dismiss the tracked time.

        Stop the tracker, dismiss the time it has tracked and
        reset values in the tracking section of the data file.
        """
        data = self.load()
        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        try:
            project_id = data["tracking"]["project"]
            msg = f"Tracker cancelled for project {self._project_name(data, project_id)}"

        except Exception as e:
            # We have to deal with an entry we cannot read (and parse) correctly.
            # This might happen if the tracker refers to a non-existing project
            # ID. We should simply deactivate the tracker.
            msg = f"Tracker cancelled but an error occurred: {e}"

        # Save the project_id as last_project (if it is a normal project)
        if project_id.isdigit():
            data["meta"]["last_project"] = project_id

        # reset tracking settings
        data["tracking"]["active"] = False
        data["tracking"]["project"] = None
        data["tracking"]["started"] = None
        data["tracking"]["comment"] = None

        print(msg)
        self.save(data, msg)


    def switch_tracking(self) -> None:
        """Switch a tracker by stopping the active tracker and starting a new one.

        This function is basically an alias of "tt stop && tt start <project>".
        """
        if len(sys.argv) < 3:
            print("You must specify a project id")
            list_projects()
            sys.exit(20)

        self.stop_tracking()
        self.start_tracking()


    def change_tracking(self) -> None:
        """Assign active tracker to new project.

        This function updates the project an already active tracker is tracking
        time in. It allows to reassign a tracker that has been started in a wrong
        project.
        """
        if len(sys.argv) < 3:
            print("You must specify a project id")
            self.list_projects()
            sys.exit(20)

        data = self.load()
        project_id = self._get_project_id(data, sys.argv[2])

        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        # Change the project ID
        data["tracking"]["project"] = project_id

        msg = f"Tracker changed to project {self._project_name(data, project_id)}"
        print(msg)
        self.save(data, msg)


    def reset_tracking(self) -> None:
        """Reset start point to now() of an active tracker.

        This will reset the start of the tracker to the current time and
        basically resets the tracker.

        Would be the same like "tt cancel && tt start <project>".
        """
        data = self.load()
        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        project_id = data["tracking"]["project"]

        # Reset tracker
        data["tracking"]["started"] = self._timestamp()

        msg = f"Tracker resetted for project {self._project_name(data, project_id)}"
        print(msg)
        self.save(data, msg)


    def pause_add(self,
            arguments: list,
            ) -> None:
        """
        """
        #print("Add pause arguments: {}".format(arguments))

        if len(arguments) < 3:
            print("""You must specify exactly 3 arguments:
                    30[-50]                 pause period in minutes
                                            (if only one number is specified a
                                            pause with this exact duration is
                                            added - if a second number is given
                                            (after a minus "-") a pause period of a
                                            random duration between the 2 numbers
                                            will be added)
                    23                      project's number or name
                    2019-03-14T09:46:26     add pause to period that starts at
                                            this point in time
                """)
            sys.exit(1)

        # Get the duration
        a_duration = arguments[0].split("-")

        if len(a_duration) == 1:
            if str(a_duration[0]).isdigit:
                pause_minutes = int(a_duration[0])
                import random
                random.seed()
                pause_seconds = random.randint(0,59)
            else:
                print(f"Duration must be of type integer, is {type(a_duration[0])}")
                sys.exit(2)

        elif len(a_duration) == 2:
            min_pause = a_duration[0]
            max_pause = a_duration[1]

            if not str(min_pause).isdigit():
                print("Minimal pause time must be of type integer")
                sys.exit(2)
            if not str(max_pause).isdigit():
                print("Maximum pause time must be of type integer")
                sys.exit(2)

            import random
            random.seed()
            pause_minutes = random.randint(int(min_pause), int(max_pause))
            pause_seconds = random.randint(0, 59)

        else:
            print("""Pause duration must be either of type integer or a range
            defined by 2 integers a and b in the form of a-b""")
            sys.exit(2)

        # Load data
        data = self.load()

        # Get the project
        project_id = self._get_project_id(data, arguments[1])
        project_name = self._get_project_name(data, project_id)
        if not str(project_id).isdigit():
            # Note that there is a project ID "p" specifying the pause project!
            print(f"{arguments[1]} is a special project - you cannot add a pause")
            sys.exit(2)

        # Get the start time stamp of the logged period
        period_start = "T".join(arguments[2:])

        # Get the tracked periods of the particular project and find a period that
        # starts with period_start
        tracked_periods = data["projects"][project_id]["history"]
        try:
            # First try to get a list of all timestamps that would match
            # the given period timestamp
            recorded_timestamps = [s[0] for s in tracked_periods if s[0].startswith(period_start)]

            if len(recorded_timestamps) == 0:
                print("Could not find time period")
                sys.exit(0)
            elif len(recorded_timestamps) > 1:
                print("Ambiguous time period, found {} possible time stamps:\n{}".format(
                    len(recorded_timestamps),
                    "\n".join(recorded_timestamps),
                    ))
                sys.exit(0)
            else:
                period_start = recorded_timestamps[0]
            pos_history = [s[0] for s in tracked_periods].index(period_start)
        except Exception as e:
            print("Could not find a period starting at {period_start} for project {self._project_name(data, project_id)}")
            return

        # We have found the period we are looking for
        # We need to split this period into 2 periods and create a new pause
        # period!
        period = tracked_periods[pos_history]

        original_start = datetime.datetime.strptime(period[0], self.dateformat)
        original_end = datetime.datetime.strptime(period[1], self.dateformat)
        original_duration = original_end - original_start

        # We divide the period exactly in the middle
        pause_time = original_duration / 2

        # Create the missing time stamps
        first_start = original_start
        first_end = original_start + pause_time
        second_start = first_end + datetime.timedelta(minutes = pause_minutes, seconds = pause_seconds)
        second_end = second_start + pause_time

        first_period = [
                datetime.datetime.strftime(first_start, self.dateformat),
                datetime.datetime.strftime(first_end, self.dateformat),
                None
                ]
        second_period = [
                datetime.datetime.strftime(second_start, self.dateformat),
                datetime.datetime.strftime(second_end, self.dateformat),
                None
                ]
        pause_period = [
                datetime.datetime.strftime(first_end, self.dateformat),
                datetime.datetime.strftime(second_start, self.dateformat),
                None
                ]

        # Before we start to modify the project's history
        # we need to find the right spot in the pause project
        if data["config"]["log_pause_times"]:
            if "p" not in data["projects"]:
                print("No pause project")
                sys.exit(1)

            pause_history = data["projects"]["p"].get("history", [])

            #print("{} pause entries".format(len(pause_history)))
            pos_pause = 0
            for p in pause_history:
                if datetime.datetime.strptime(p[0], self.dateformat) <= first_end:
                    pos_pause += 1
                else:
                    break

        # Now we modify the histories

        # Modify the project's history
        # Delete the original period ...
        del(tracked_periods[pos_history])
        # ... and insert the 2 new periods
        tracked_periods.insert(pos_history, first_period)
        tracked_periods.insert(pos_history + 1, second_period)

        # Add the new pause period to the pause history
        if data["config"]["log_pause_times"]:
            pause_history.insert(pos_pause, pause_period)


        # Save the data to the data structure
        data["projects"][project_id]["history"] = tracked_periods
        if data["config"]["log_pause_times"]:
            data["projects"]["p"]["history"] = pause_history

        # Finally, save the data structure back to disk
        # Provide a message for the user to let him know what's going on
        msg = f"Added pause of {pause_minutes:02d}:{pause_seconds:02d} minutes in project {self._project_name(data, project_id)} at {pause_period[0]}"

        print(msg)
        self.save(data, msg=msg)


    def pause_tracking(self) -> None:
        """Pauses a tracker.

        This function only works if tracking pause times is enabled in the local
        configuration. Otherwise this function will exit with an error code.
        If activated the current tracker will be stopped and the tracker of the
        special pause project will be started.

        The opposite of this function is resume_tracking().
        """
        if len(sys.argv) >= 3:
            if sys.argv[2].lower() == "enable":
                self.enable_pause()
            elif sys.argv[2].lower() == "disable":
                self.disable_pause()
            elif sys.argv[2].lower() == "add":
                self.pause_add(sys.argv[3:])
            else:
                print(f"Unsupported argument(s): {' '.join(sys.argv[2:])}")
            sys.exit(0)

        data = self.load()

        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        if not data["config"]["log_pause_times"]:
            print("Disabled in local configuration - try \"tt stop\" instead")
            sys.exit(42)

        try:
            # Stop the running "normal" tracker
            project_id = data["tracking"]["project"]

            if project_id == 'p':
                print("Already paused")
                sys.exit(24)

            started = data["tracking"]["started"]
            stopped = self._timestamp()
            diff, hf, hhmm = self._time_diff(started, stopped)

            comment = data["tracking"]["comment"]

            # add tuple to history
            history = data["projects"][project_id]["history"]
            history.append( (started, stopped, comment) )
            data["projects"][project_id]["history"] = history

            # Start the pause tracker
            # project_id = data["meta"]["last_project"]
            data["tracking"]["active"] = True
            data["tracking"]["project"] = 'p'
            data["tracking"]["started"] = self._timestamp()
            data["tracking"]["comment"] = None

            msg = f"Paused tracker for project {self._project_name(data, project_id)} after {hhmm} ({hf:1.2f} hours)"

            if comment:
                msg += f": \"{comment}\""

            # Save the project_id as last_project
            data["meta"]["last_project"] = project_id

            print(msg)

        except Exception as e:
            # We have to deal with an entry we cannot read (and parse) correctly.
            # This might happen if the tracker refers to a non-existing project
            # ID. We should simply deactivate the tracker.
            msg = f"Error occurred while trying to pause tracker: {e}"
            print(msg)

        self.save(data, msg)


    def resume_tracking(self) -> None:
        """Resume a tracker.

        This function does work even if tracking of pause times is disabled.
        However, if tt is in pause mode this function will stop the tracker
        of the pause project and start the tracker of the project that has
        been paused. It's ID is saved as last_project in the meta section
        of the data file.

        If there is no running (pause) tracker this function will start a
        new timer for the project id saved as last_project in the meta
        section of the data file.
        """
        data = self.load()

        # If resume is called and not tracker is active, we will start a
        # new tracker for the last project used
        if not data["tracking"]["active"]:
            self.start_tracking(data["meta"]["last_project"])
            sys.exit(0)

        try:
            project_id = data["tracking"]["project"]

            if project_id != 'p':
                print("No pause tracker")
                sys.exit(22)

            started = data["tracking"]["started"]
            stopped = self._timestamp()
            diff, hf, hhmm = self._time_diff(started, stopped)

            comment = data["tracking"]["comment"]

            # add tuple to history
            history = data["projects"]['p']["history"]
            history.append( (started, stopped, comment) )
            data["projects"]['p']["history"] = history

            # Resume old tracker
            project_id = data["meta"]["last_project"]
            data["tracking"]["active"] = True
            data["tracking"]["project"] = project_id
            data["tracking"]["started"] = self._timestamp()
            data["tracking"]["comment"] = None

            msg = f"Resumed tracker for project {self._project_name(data, project_id)} after pause of {hhmm} ({hf:1.2f} hours)"

            if comment:
                msg += f": \"{comment}\""

            print(msg)

        except Exception as e:
            # We have to deal with an entry we cannot read (and parse) correctly.
            # This might happen if the tracker refers to a non-existing project
            # ID. We should simply deactivate the tracker.
            msg = f"Error occurred while trying to pause tracker: {e}"
            print(msg)

        self.save(data, msg)


    def add_comment(self) -> None:
        """Switch a tracker by stopping the active tracker and starting a new one.

        This function is basically an alias of "tt stop && tt start <project>".
        """
        # data = load()
        # if not data["tracking"]["active"]:
        #     print("No active tracker")
        #     sys.exit(22)

        data = self.load()

        if not data["tracking"]["active"]:
            print("No active tracker")
            sys.exit(22)

        if len(sys.argv) < 3:
            print("You must provide (at least one word as) a comment")
            sys.exit(50)

        comment = " ".join(sys.argv[2:]).strip()

        project_id = data["tracking"]["project"]
        data["tracking"]["comment"] = comment

        msg = f"Added comment to project {self._project_name(data, project_id)}: {comment}"
        self.save(data, msg)
        print(msg)



    # TODO: def delete_comment(self) -> None:


    #############################################################################
    ### Output
    #############################################################################

    def show(self,
            limit: int = 10,
            ) -> None:
        """Show the recorded times.

        You can specify a project ID to show only the times for this particular
        project. If you do not specify a particular project, a list of all
        recorded times will be printed to the console in the following format:
          1   LRZ
                  2017-07-31      07:53 - 16:58      09:05  (9.08 hours)
                  2017-08-07      07:15 - 15:22      08:07  (8.12 hours)
                  2017-08-10      07:56 - 11:00      03:04  (3.07 hours)
                                  11:01 - 16:46      05:45  (5.76 hours)

        If limit is specifed, only the last limit + 1 log entries are displayed
        when no project ID is given (i.e. in the overview page). If a project
        ID is given, this limit will be ignored because we assume that the user
        wants to see every detail of the particular project.

        A running tracker will displayed independently from the limit.
        limit specifies the number of "finished" log entries to display.

        The special pause project will only be displayed if tracking pause
        times is enabled in the local configuration.

        :param limit:   Number of entries to max. display per project
        :type limit:    int
        """
        data = self.load()
        project_ids = list() # list of project ids to display
        detailed_view = False

        if len(sys.argv) < 3:
            # no project ID given, get list of all available project IDs
            project_ids = sorted(list(data["projects"].keys()))
        elif len(sys.argv) >= 3:
            # project ID given, use it
            project_ids = sys.argv[2:]
            # project IDs are given, ignoring the limit
            limit = 0
            detailed_view = True

        running_tracker = False
        try:
            running_tracker = data["tracking"]["active"]
            running_project = data["tracking"]["project"]
            running_since = data["tracking"]["started"]
            running_comment = data["tracking"]["comment"]
            running_since_day, running_since_time = self._to_day_and_time(running_since)
        except:
            # in case of any error, set running_tracker to False
            running_tracker = False

        for raw_project_id in project_ids:
            project_id = self._get_project_id(data, raw_project_id)

            # Do not display pause project if pause times should not
            # be logged
            if project_id == 'p' and not data.get("config", {}).get("log_pause_times", False):
                continue

            if project_id is None:
                # could not look up project's ID
                # inform user and continue with next ID
                print(f"Project {bcolors.YELLOW}{raw_project_id}{bcolors.END} not found")
                continue

            try:
                project_name = data["projects"][project_id]["name"]
                history = data["projects"][project_id]["history"]
            except KeyError as e:
                # Key (project_id) not found
                # continue with next loop run
                continue

            # Print the project's name
            if project_id.isdigit():
                print(f"    {bcolors.YELLOW}{project_id:>3}{bcolors.END}   {project_name}")
            else:
                print(f"    {bcolors.BLUE}{project_id:>3}{bcolors.END}   {project_name}")

            # print the history
            if len(history) == 0:
                if not running_tracker or running_project != project_id:
                    # Print only if there is no currently active tracker
                    # for this project
                    print("              No entries")

            old_day = ""
            total = 0.0
            day_total = 0.0

            if limit and limit < len(history):
                history_to_display = history[(len(history) - limit):]
                skipped = len(history) - limit
                if skipped > 0:
                    if skipped == 1:
                        txt = "1 more entry"
                    else:
                        txt = f"{skipped} more entries"

                    print(f"              ... {txt} - use \"{self.my_name} {sys.argv[1]} {project_id}\" to display complete history")
            else:
                history_to_display = history

            for item in sorted(history_to_display):
                started, stopped, comment = item
                secs, hf, hhmm = self._time_diff(started, stopped)
                total = total + hf
                day, time_started = self._to_day_and_time(started)
                _, time_stopped = self._to_day_and_time(stopped)
                str_day = f"{day:16}"
                if day != old_day:
                    day_total = hf
                    str_day_total = ""
                else:
                    str_day = " " * 16
                    day_total = day_total + hf
                    str_day_total = f"{' ' * 6}{day_total:1.2f} hours total"

                if not comment:
                    comment = ""
                else:
                    str_day_total += " " * (22 - len(str_day_total))
                    comment = f"{bcolors.CYAN}{comment}{bcolors.END}"

                print(f"              {str_day}{time_started:5} - {time_stopped:11}{hhmm:7}({hf:1.2f} hours){str_day_total}      {comment}")
                old_day = day

            if running_tracker and running_project == project_id:
                # TODO: Cleanup this stuff
                day, time_started = self._to_day_and_time(running_since)
                time_stopped = ""
                _, hf, hhmm = self._time_diff(running_since, self._timestamp())
                total = total + hf
                str_day = f"{running_since_day:16}"
                str_day_total = f"{' ' * 6}tracking"

                if running_since_day == old_day:
                    str_day = " " * 16
                    day_total = day_total + hf
                    str_day_total = f"{' ' * 6}{day_total:1.2f} hours total (tracking)"

                if not running_comment:
                    running_comment = ""
                else:
                    running_comment = f"{bcolors.CYAN}{comment}{bcolors.END}"

                print(f"              {str_day}{time_started:5} - {time_stopped:11}{hhmm:7}({hf:1.2f} hours){str_day_total}      {running_comment}")

            if detailed_view:
                print(f"              Total time tracked: {total:9.2f} hours")


    def csv(self,
            table: bool= False,
            ) -> None:
        """Outputs the tracked time(s) of a particular project in a format that can be
        easily pasted to our "Zeiterfassungsbogen".

        :param table:   Print a pretty table instead of boring comma-separated values
        :type table:    bool
        """
        data = self.load()
        project_ids = list() # list of project ids to display

        # We only support to display a single project
        # to be able to keep the output clean and easily usable
        # to be automatically fed to another application for further
        # utilization

        if len(sys.argv) != 3:
            print("You must specify exactly one project to display")
            sys.exit(0)

        raw_project_id = sys.argv[2]
        project_id = self._get_project_id(data, raw_project_id)

        try:
            project_name = data["projects"][project_id]["name"]
            history = data["projects"][project_id]["history"]
        except KeyError as e:
            # Key (project_id) not found
            print(f"Project {bcolors.YELLOW}{raw_project_id}{bcolors.END} not found")
            return

        dict_to_print = {}
        # { "YYYY-MM-DD": {
        #       "day_total": float,
        #       "entries": [str],
        #   }
        # }

        for item in sorted(history):
            started, stopped, comment = item
            secs, hf, hhmm = self._time_diff(started, stopped)
            day, time_started = self._to_day_and_time(started)
            _, time_stopped = self._to_day_and_time(stopped)
            entries_to_print = []

            # Get entries for particular day
            day_data = dict_to_print.get(day, {})
            day_entries = day_data.get("entries", [])
            day_total = day_data.get("day_total", 0.0)

            day_total = day_total + hf
            o_started = datetime.datetime.strptime(started, self.dateformat)
            o_stopped = datetime.datetime.strptime(stopped, self.dateformat)
            s_started = datetime.datetime.strftime(o_started, "%H:%M")
            s_stopped = datetime.datetime.strftime(o_stopped, "%H:%M")

            day_entries.append(f"{s_started} - {s_stopped}")

            day_data["day_total"] = day_total
            day_data["entries"] = day_entries
            dict_to_print[day] = day_data

        # Now we need to print it
        delimiter = ";"

        if table:
            # Use PrettyTable to create a pretty table
            try:
                from prettytable import PrettyTable
                t = PrettyTable()

                t.field_names = ["Day", "Times", "Hours"]
                t.align["Day"] = "l"
                t.align["Times"] = "l"
                t.align["Hours"] = "r"

            except Exception as e:
                print("Could not import module prettytable")
                sys.exit(6)

        for day in sorted(dict_to_print.keys()):
            day_data = dict_to_print[day]
            entries = ", ".join(day_data["entries"])
            f_day_total = f"{day_data['day_total']:.2f}"
            day_total = str(f_day_total).replace(".", ",")

            if table:
                t.add_row([day, entries, day_total])
            else:
                print(f"\"{day}\"{delimiter}\"{entries}\"{delimiter}\"{day_total}\"")

        if table:
            print(t)


    #############################################################################
    ### Reports
    #############################################################################

    def week(self,
            project_id: str = None,
            ) -> None:
        """Print the time tracked for the current week.

        :param project_id:  Show only times for particular project
        :type project_id:   str or None
        """
        self.weekly(project_id, num_weeks = 1)


    def weekly(self,
            project_id: str = None,
            num_weeks: int = 10,
            week_starts_sunday = False
            ):
        """Print  a weekly report of your tracked time

        :param project_id:          ID of project
        :type project_id:           str or None
        :param num_weeks:           Number of weeks to display
        :type num_weeks:            int
        :param week_starts_sunday:  Set to True if week starts on Sunday (Monday otherwise)
        :type week_starts_sunday:   bool
        """

        if project_id is None:
            if len(sys.argv) >= 3:
                project_id = sys.argv[2]
            else:
                print("You must provide a project ID.")
                sys.exit(20)
                # TODO: The sum of hours is calculated wrongly if we do not
                #       limit it to a single project.
                #       One Problem is that pause times, ... are added to that.
                #       Somehow

        data = self.load()

        # Look up the project ID in the data dict (if name was given)
        if project_id is not None:
            project_id = self._get_project_id(data, project_id)

        # First step is to get the date_prefix for the first day of the current
        # week
        # Get the first day of the week.
        # Source: https://stackoverflow.com/questions/39441639/getting-the-date-of-the-first-day-of-the-week#comment113182133_61743379
        # isoweekday() - Monday is 1 and Sunday is 7
        # weekday() - Monday is 0 and Sunday is 6
        if week_starts_sunday:
            dt_first_day = datetime.datetime.today() - datetime.timedelta(days=datetime.datetime.today().isoweekday() % 7)
        else:
            dt_first_day = datetime.datetime.today()  - datetime.timedelta(days=datetime.datetime.today().weekday() % 7)

        # We need to create a set of date_prefixes containing the dates of
        # each of days for the particular week(s) we want to print.

        # The numbering of the weeks is as follows:
        # weeknum   times to display
        # ---------+---------------------------------------------------------
        #       1   current week
        #       2   week before current week
        #       3   week before week 2
        #       4   week before week 3
        # ...
        # You got the idea.
        weeks = []
        for weeknum in range(num_weeks):
            # We need to reset the datetime object representing the first day
            # of the week.
            # We only need to do that if the weeknum is greater than zero.
            if weeknum:
                dt_first_day = dt_first_day - datetime.timedelta(days = 7)

            days_of_week = []
            days_of_week = [dt_first_day.strftime("%Y-%m-%d")]

            for other_day in range(6):
                days_of_week.append((dt_first_day + datetime.timedelta(days = 1 + other_day)).strftime("%Y-%m-%d"))

            weeks.append(days_of_week)

        result = {}

        for week in weeks:
            first_day = week[0]
            last_day = week[-1]
            result_key = f"{first_day} - {last_day}"

            trackings = self._get_trackings(
                    data = data,
                    project_id = project_id,
                    date_prefix = week,
                    )

            for project, slots in trackings.items():
                week_secs = 0.0
                for s in slots:
                    secs, _, _ = self._time_diff(s[0], s[1])
                    week_secs += secs

                # Store the data in the results dict for printing
                project_dict = result.get(project_id, {})
                project_dict[result_key] = week_secs
                result[project_id] = project_dict


        # Print the results
        for pid, timeslots in result.items():
            print(f"Project {self._project_name(data, project_id)}")

            for week in sorted(timeslots.keys()):
                hf = self._convert_seconds_to_hf(timeslots.get(week, 0))
                print(f"    {week}: {hf:>9.2f} hours")





    #############################################################################
    ### Entry point
    #############################################################################

    """Main function/entry point when starting the program.

    Parses the arguments and calls the appropriate functions.
    """
    def __init__(self,
            argv: list,
            ):

        # Sanity check: only proceed if we are in a python3 environment
        try:
            assert sys.version_info >= (3,6)
        except:
            print(f"Python 3.6 is required to run {self.my_name}")
            sys.exit(1)

        if len(sys.argv) == 2 and sys.argv[1].lower() == "init":
            self.init()
            sys.exit(0)
        elif len(sys.argv) <= 1:
            self.status()
            sys.exit(0)

        cmd = self.parse_command(sys.argv[1].lower())

        if cmd == "status":
            self.status()
        elif cmd == "log":
            self.print_log()
        elif cmd == "cleanup":
            self.cleanup()

        elif cmd == "aliases":
            self.print_aliases()
        elif cmd == "alias":
            self.alias()
        elif cmd == "unalias":
            self.unalias()

        elif cmd == "list":
            self.list_projects()
        elif cmd == "add":
            self.add_project()
        elif cmd == "delete":
            self.delete_project()
        elif cmd == "rename":
            self.rename_project()
        elif cmd == "show":
            self.show()
        elif cmd == "csv":
            self.csv()
        elif cmd == "tab":
            self.csv(table = True)

        elif cmd == "default":
            self.set_default_project()
        elif cmd == "undefault":
            self.unset_default_project()

        elif cmd == "pause":
            self.pause_tracking()
        elif cmd == "resume":
            self.resume_tracking()
        elif cmd == "start":
            self.start_tracking()
        elif cmd == "stop":
            self.stop_tracking()
        elif cmd == "switch":
            self.switch_tracking()
        elif cmd == "change":
            self.change_tracking()
        elif cmd == "cancel":
            self.cancel_tracking()
        elif cmd == "reset":
            self.reset_tracking()
        elif cmd == "comment":
            self.add_comment()

        elif cmd == "week":
            self.week()
        elif cmd == "weekly":
            self.weekly()

        else:
            self.usage()


class bcolors:
    """
    Define some colors that can be used in the terminal.
    Source: https://gist.github.com/vratiu/9780109
    """
    # Reset
    END = "\033[0m"             # Text Reset

    # Regular Colors
    BLACK = "\033[0;30m"        # Black
    RED = "\033[0;31m"          # Red
    GREEN = "\033[0;32m"        # Green
    YELLOW = "\033[0;33m"       # Yellow
    BLUE = "\033[0;34m"         # Blue
    PURPLE = "\033[0;35m"       # Purple
    CYAN = "\033[0;36m"         # Cyan
    WHITE = "\033[0;37m"        # White

    # Bold
    BBLACK="\033[1;30m"         # Black
    BRED = "\033[1;31m"         # Red
    BGREEN = "\033[1;32m"       # Green
    BYELLOW = "\033[1;33m"      # Yellow
    BBLUE = "\033[1;34m"        # Blue
    BPURPLE = "\033[1;35m"      # Purple
    BCYAN = "\033[1;36m"        # Cyan
    BWHITE = "\033[1;37m"       # White

    # Underline
    UBLACK = "\033[4;30m"       # Black
    URED = "\033[4;31m"         # Red
    UGREEN = "\033[4;32m"       # Green
    UYELLOW = "\033[4;33m"      # Yellow
    UBLUE = "\033[4;34m"        # Blue
    UPURPLE = "\033[4;35m"      # Purple
    UCYAN = "\033[4;36m"        # Cyan
    UWHITE = "\033[4;37m"       # White



if __name__ == '__main__':
    tt = TymeTracker(sys.argv)

# EOF